#!/usr/bin/env bash
# shellcheck shell=bash
# shellcheck disable=SC2034

ICHRISBIRCH_HOME="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && git rev-parse --show-toplevel)"

if [[ $(uname) == "Darwin" ]]; then
  LOG_DIR="/usr/local/var/log/ichrisbirch"
else
  LOG_DIR="/var/log/ichrisbirch"
fi

export LOG_DIR

red=$(tput setaf 1)
green=$(tput setaf 2)
yellow=$(tput setaf 3)
blue=$(tput setaf 4)
magenta=$(tput setaf 5)
cyan=$(tput setaf 6)
white=$(tput setaf 7)
gray=$(tput setaf 8)
bright_red=$(tput setaf 9)
bright_green=$(tput setaf 10)
bright_yellow=$(tput setaf 11)
bright_blue=$(tput setaf 12)
bright_magenta=$(tput setaf 13)
bright_cyan=$(tput setaf 14)
orange=$(tput setaf 208) # 256-color orange
reset=$(tput sgr0)

function colored-logs() {
  local RED_ERROR="${red}[ERROR]${reset}"
  local YELLOW_WARNING="${yellow}[WARNING]${reset}"
  local BLUE_INFO="${blue}[INFO]${reset}"
  local GREEN_DEBUG="${green}[DEBUG]${reset}"
  local MAGENTA_CRITICAL="${magenta}[CRITICAL]${reset}"

  # Service name colors
  local RED_REDIS="${red}redis${reset}"
  local GREEN_POSTGRES="${green}postgres${reset}"
  local CYAN_NGINX="${cyan}nginx${reset}"
  local BRIGHT_GREEN_API="${bright_green}api${reset}"
  local BRIGHT_BLUE_APP="${bright_blue}app${reset}"
  local ORANGE_CHAT="${orange}chat${reset}"
  local YELLOW_SCHEDULER="${yellow}scheduler${reset}"

  # Use sed with proper escaping for backslashes
  # Note: -testing must come before -test to avoid leaving "ing" suffix
  sed \
    -e 's/ichrisbirch-//g' \
    -e 's/-dev//g' \
    -e 's/-testing//g' \
    -e 's/-test//g' \
    -e 's/^api[ ]*|/'"${BRIGHT_GREEN_API}"' |/' \
    -e 's/^app[ ]*|/'"${BRIGHT_BLUE_APP}"' |/' \
    -e 's/^redis[ ]*|/'"${RED_REDIS}"' |/' \
    -e 's/^postgres[ ]*|/'"${GREEN_POSTGRES}"' |/' \
    -e 's/^nginx[ ]*|/'"${CYAN_NGINX}"' |/' \
    -e 's/^chat[ ]*|/'"${ORANGE_CHAT}"' |/' \
    -e 's/^scheduler[ ]*|/'"${YELLOW_SCHEDULER}"' |/' \
    -e 's/\[ERROR\]/'"${RED_ERROR}"'/g' \
    -e 's/\[WARNING\]/'"${YELLOW_WARNING}"'/g' \
    -e 's/\[DEBUG\]/'"${GREEN_DEBUG}"'/g' \
    -e 's/\[INFO\]/'"${BLUE_INFO}"'/g' \
    -e 's/\[CRITICAL\]/'"${MAGENTA_CRITICAL}"'/g'
}

function parse-json-logs() {
  # Parse JSON structlog output and format for console display
  # Falls back to raw output if not valid JSON (e.g., non-JSON log lines)
  jq -r '
    # Extract timestamp, level, and event
    "\(.timestamp // .asctime // "unknown") [\(.level // "INFO" | ascii_upcase)] \(.event // "unknown") " +
    # Add all other fields as key=value pairs
    (to_entries | map(select(.key | IN("timestamp", "asctime", "level", "event", "filename", "func_name", "lineno") | not)) |
     map("\(.key)=\(.value)") | join(" "))
  ' 2>/dev/null || cat
}

function colored-status() {
  local GREEN_RUNNING="${green}running${reset}"
  local RED_EXITED="${red}exited${reset}"
  local YELLOW_RESTARTING="${yellow}restarting${reset}"
  local BLUE_PAUSED="${blue}paused${reset}"
  local MAGENTA_DEAD="${magenta}dead${reset}"
  local CYAN_CREATED="${cyan}created${reset}"
  local YELLOW_UNHEALTHY="${yellow}unhealthy${reset}"
  local GREEN_HEALTHY="${green}healthy${reset}"

  awk -v running="$GREEN_RUNNING" \
    -v exited="$RED_EXITED" \
    -v restarting="$YELLOW_RESTARTING" \
    -v paused="$BLUE_PAUSED" \
    -v dead="$MAGENTA_DEAD" \
    -v created="$CYAN_CREATED" \
    -v unhealthy="$YELLOW_UNHEALTHY" \
    -v healthy="$GREEN_HEALTHY" '
    {
        # Strip ichrisbirch- prefix from service names
        gsub(/ichrisbirch-/, "");
        # Color container states using gsub for all matches
        gsub(/running/, running);
        gsub(/exited/, exited);
        gsub(/restarting/, restarting);
        gsub(/paused/, paused);
        gsub(/dead/, dead);
        gsub(/created/, created);
        gsub(/unhealthy/, unhealthy);
        gsub(/healthy/, healthy);
        print $0;
    }'
}

function logs() {
  cd "$LOG_DIR" || exit
  ls -lH
  exec $SHELL
}

function install() {
  sudo ln -sf "$ICHRISBIRCH_HOME/cli/ichrisbirch" /usr/local/bin/ichrisbirch
}

function open() {
  cd "$ICHRISBIRCH_HOME" || exit
  echo "Opening ${green}ichrisbirch${reset} project in VS Code"
  code .
  echo "Starting tmux session"
  exec tmux new-session -d -s ichrisbirch || tmux attach-session -t ichrisbirch
}

function project-cd() {
  cd "$ICHRISBIRCH_HOME" || exit
  if [ -d ".venv" ]; then
    echo "Activating virtual environment"
    # shellcheck source=/dev/null
    source .venv/bin/activate
  fi
  exec "$SHELL"
}

# ============================================================================
# SSL CERTIFICATE MANAGEMENT
# ============================================================================

function ssl-manager() {
  local action="${1:-info}"
  local environment="${2:-all}"

  cd "$ICHRISBIRCH_HOME" || exit

  if [ -x "./deploy-containers/traefik/scripts/ssl-manager.sh" ]; then
    ./deploy-containers/traefik/scripts/ssl-manager.sh "$action" "$environment"
  else
    echo "${red}SSL manager script not found${reset}"
    echo "Expected: ${cyan}./deploy-containers/traefik/scripts/ssl-manager.sh${reset}"
    return 1
  fi
}

function dev-start() {
  cd "$ICHRISBIRCH_HOME" || exit

  # Ensure proxy network exists for Traefik
  if ! docker network inspect proxy >/dev/null 2>&1; then
    echo "Creating external proxy network..."
    docker network create proxy
  fi

  echo "Starting ${blue}DEV${reset} environment with ${green}Docker Compose + Traefik (HTTPS)${reset}"
  docker compose --project-name ichrisbirch-dev -f docker-compose.yml -f docker-compose.dev.yml up -d

  echo ""
  echo "Development environment started with ${green}HTTPS${reset}:"
  echo "  ${green}API${reset}:       ${cyan}https://api.docker.localhost/${reset}"
  echo "  ${green}APP${reset}:       ${cyan}https://app.docker.localhost/${reset}"
  echo "  ${green}CHAT${reset}:      ${cyan}https://chat.docker.localhost/${reset}"
  echo "  ${green}DASHBOARD${reset}: ${cyan}https://dashboard.docker.localhost/${reset} (user: dev, pass: devpass)"
  echo ""
  echo "Legacy HTTP access also available:"
  echo "  ${green}APP${reset}: ${cyan}http://localhost:5000${reset}"
  echo "  ${green}API${reset}: ${cyan}http://localhost:8000${reset}"
  echo "  ${green}CHAT${reset}: ${cyan}http://localhost:8505${reset}"
  echo "  ${green}PostgreSQL${reset}: ${cyan}localhost:5432${reset}"
  echo "  ${green}Redis${reset}: ${cyan}localhost:6379${reset}"
  echo ""
  echo "Use ${blue}ichrisbirch dev logs${reset} to view live container logs"
  echo "Use ${blue}ichrisbirch dev status${reset} to check service status"
  echo "Use ${blue}ichrisbirch dev health${reset} to run health checks"
}

function dev-stop() {
  cd "$ICHRISBIRCH_HOME" || exit
  echo "Stopping ${blue}DEV${reset} environment"
  docker compose --project-name ichrisbirch-dev -f docker-compose.yml -f docker-compose.dev.yml down
}

function dev-restart() {
  cd "$ICHRISBIRCH_HOME" || exit
  echo "Restarting ${blue}DEV${reset} environment"
  # Use 'up -d' instead of 'restart' to pick up any configuration changes
  docker compose --project-name ichrisbirch-dev -f docker-compose.yml -f docker-compose.dev.yml up -d
}

function dev-rebuild() {
  cd "$ICHRISBIRCH_HOME" || exit
  echo "Rebuilding and restarting ${blue}DEV${reset} environment"
  docker compose --project-name ichrisbirch-dev -f docker-compose.yml -f docker-compose.dev.yml down
  docker compose --project-name ichrisbirch-dev -f docker-compose.yml -f docker-compose.dev.yml up -d --build
}

function dev-logs() {
  cd "$ICHRISBIRCH_HOME" || exit

  # Check for --json flag
  local json_mode=false
  local services=()
  for arg in "$@"; do
    if [[ "$arg" == "--json" ]]; then
      json_mode=true
    else
      services+=("$arg")
    fi
  done

  echo "Viewing ${blue}DEV${reset} Docker container logs..."
  if [[ "$json_mode" == true ]]; then
    echo "Mode: ${cyan}JSON parsing${reset} (use without --json for console format)"
  fi
  echo ""

  # Build docker compose command
  local compose_cmd="docker compose --project-name ichrisbirch-dev -f docker-compose.yml -f docker-compose.dev.yml logs --follow --tail=50"
  if [[ ${#services[@]} -gt 0 ]]; then
    compose_cmd="$compose_cmd ${services[*]}"
  fi

  # Show live Docker Compose logs with appropriate formatting
  if [[ "$json_mode" == true ]]; then
    $compose_cmd | parse-json-logs | colored-logs
  else
    $compose_cmd | colored-logs
  fi
}

function dev-status() {
  cd "$ICHRISBIRCH_HOME" || exit
  echo "${blue}DEV${reset} environment status:"
  echo ""

  # Show container status with colors
  docker compose --project-name ichrisbirch-dev -f docker-compose.yml -f docker-compose.dev.yml ps --format "table {{.Service}}\t{{.State}}\t{{.Ports}}" | colored-status

  echo ""
  echo "${blue}Development${reset} URLs:"
  echo "  • API:       https://api.docker.localhost/"
  echo "  • App:       https://app.docker.localhost/"
  echo "  • Chat:      https://chat.docker.localhost/"
  echo "  • Dashboard: https://dashboard.docker.localhost/ (user: dev, pass: devpass)"
}

function dev-monitor() {
  tmuxinator ichrisbirch-dev-monitoring
}

function dev-health() {
  echo "Running health check for ${blue}DEV${reset} environment"

  cd "$ICHRISBIRCH_HOME" || exit

  if [ -x "./deploy-containers/traefik/scripts/health-check.sh" ]; then
    ./deploy-containers/traefik/scripts/health-check.sh dev
  else
    echo "${red}Health check script not found${reset}"
    echo "Expected: ${cyan}./deploy-containers/traefik/scripts/health-check.sh${reset}"
    return 1
  fi
}

function test-run() {
  cd "$ICHRISBIRCH_HOME" || exit
  mkdir -p "$ICHRISBIRCH_HOME/test-logs"
  # shellcheck disable=1091
  source "$ICHRISBIRCH_HOME/.venv/bin/activate"
  export ENVIRONMENT=testing

  # Parse --keep flag (preserves containers after tests)
  local keep_containers=false
  local pytest_args=()
  for arg in "$@"; do
    if [[ "$arg" == "--keep" ]]; then
      keep_containers=true
    else
      pytest_args+=("$arg")
    fi
  done

  # Ensure clean state - stop any existing test containers
  echo "${blue}Stopping any existing test containers...${reset}"
  docker compose --project-name ichrisbirch-test -f docker-compose.yml -f docker-compose.test.yml down --volumes 2>/dev/null || true

  # Ensure proxy network exists
  if ! docker network inspect proxy >/dev/null 2>&1; then
    docker network create proxy
  fi

  # Start fresh containers
  echo "${blue}Starting test containers...${reset}"
  docker compose --project-name ichrisbirch-test -f docker-compose.yml -f docker-compose.test.yml up -d

  echo "Waiting for services to be ready..."
  sleep 15

  # Initialize test database
  echo "${blue}Initializing test database...${reset}"
  if ! ENVIRONMENT=testing uv run python -m ichrisbirch.database.initialization --env testing --db-host localhost --db-port 5434; then
    echo "${red}Database initialization failed${reset}"
    if [[ "$keep_containers" == false ]]; then
      docker compose --project-name ichrisbirch-test -f docker-compose.yml -f docker-compose.test.yml down --volumes
    fi
    return 1
  fi

  # Run pytest
  echo ""
  echo "${green}Running tests...${reset}"
  echo ""
  local test_exit_code=0
  if [ ${#pytest_args[@]} -eq 0 ]; then
    uv run pytest || test_exit_code=$?
  else
    uv run pytest "${pytest_args[@]}" || test_exit_code=$?
  fi

  # Stop containers unless --keep was specified
  if [[ "$keep_containers" == true ]]; then
    echo ""
    echo "${yellow}Containers kept running (--keep flag).${reset}"
    echo "Stop them later with: ${cyan}ichrisbirch testing stop${reset}"
  else
    echo ""
    echo "${blue}Stopping test containers...${reset}"
    docker compose --project-name ichrisbirch-test -f docker-compose.yml -f docker-compose.test.yml down --volumes
  fi

  return $test_exit_code
}

function test-cov() {
  cd "$ICHRISBIRCH_HOME" || exit
  mkdir -p "$ICHRISBIRCH_HOME/test-logs"
  # shellcheck disable=1091
  source "$ICHRISBIRCH_HOME/.venv/bin/activate"
  export ENVIRONMENT=testing

  # Parse --keep flag (preserves containers after tests)
  local keep_containers=false
  local pytest_args=()
  for arg in "$@"; do
    if [[ "$arg" == "--keep" ]]; then
      keep_containers=true
    else
      pytest_args+=("$arg")
    fi
  done

  # Ensure clean state - stop any existing test containers
  echo "${blue}Stopping any existing test containers...${reset}"
  docker compose --project-name ichrisbirch-test -f docker-compose.yml -f docker-compose.test.yml down --volumes 2>/dev/null || true

  # Ensure proxy network exists
  if ! docker network inspect proxy >/dev/null 2>&1; then
    docker network create proxy
  fi

  # Start fresh containers
  echo "${blue}Starting test containers...${reset}"
  docker compose --project-name ichrisbirch-test -f docker-compose.yml -f docker-compose.test.yml up -d

  echo "Waiting for services to be ready..."
  sleep 15

  # Initialize test database
  echo "${blue}Initializing test database...${reset}"
  if ! ENVIRONMENT=testing uv run python -m ichrisbirch.database.initialization --env testing --db-host localhost --db-port 5434; then
    echo "${red}Database initialization failed${reset}"
    if [[ "$keep_containers" == false ]]; then
      docker compose --project-name ichrisbirch-test -f docker-compose.yml -f docker-compose.test.yml down --volumes
    fi
    return 1
  fi

  # Run pytest with coverage
  echo ""
  echo "${green}Running tests with coverage...${reset}"
  echo ""
  local test_exit_code=0
  if [ ${#pytest_args[@]} -eq 0 ]; then
    uv run pytest --cov=ichrisbirch --cov-report=html || test_exit_code=$?
  else
    uv run pytest --cov=ichrisbirch --cov-report=html "${pytest_args[@]}" || test_exit_code=$?
  fi

  echo ""
  echo "Coverage report: ${cyan}file://$ICHRISBIRCH_HOME/htmlcov/index.html${reset}"

  # Stop containers unless --keep was specified
  if [[ "$keep_containers" == true ]]; then
    echo ""
    echo "${yellow}Containers kept running (--keep flag).${reset}"
    echo "Stop them later with: ${cyan}ichrisbirch testing stop${reset}"
  else
    echo ""
    echo "${blue}Stopping test containers...${reset}"
    docker compose --project-name ichrisbirch-test -f docker-compose.yml -f docker-compose.test.yml down --volumes
  fi

  return $test_exit_code
}

function testing-start() {
  cd "$ICHRISBIRCH_HOME" || exit

  # Create test-logs directory if it doesn't exist
  mkdir -p "$ICHRISBIRCH_HOME/test-logs"

  # Ensure proxy network exists for Traefik
  if ! docker network inspect proxy >/dev/null 2>&1; then
    echo "Creating external proxy network..."
    docker network create proxy
  fi

  echo "Starting ${blue}TESTING${reset} environment with ${green}Docker Compose + Traefik (HTTPS)${reset}"
  docker compose --project-name ichrisbirch-test -f docker-compose.yml -f docker-compose.test.yml up -d

  echo "Waiting for services to be ready..."
  sleep 15

  echo "Initializing test database..."
  # Use virtual environment and run database initialization
  # shellcheck disable=1091
  source "$ICHRISBIRCH_HOME/.venv/bin/activate"

  # Run test database initialization from host (need to use localhost, not Docker hostname)
  if ENVIRONMENT=testing uv run python -m ichrisbirch.database.initialization --env testing --db-host localhost --db-port 5434; then
    echo "${green}Database initialized successfully${reset}"
  else
    echo "${red}Database initialization failed${reset}"
    echo "Check logs for details. You may need to run:"
    echo "   ${blue}ichrisbirch testing stop${reset}"
    echo "   ${blue}ichrisbirch testing start${reset}"
    return 1
  fi

  echo ""
  echo "Testing environment started with ${green}HTTPS${reset}:"
  echo "  ${green}API${reset}:       ${cyan}https://api.test.localhost:8443/${reset}"
  echo "  ${green}APP${reset}:       ${cyan}https://app.test.localhost:8443/${reset}"
  echo "  ${green}CHAT${reset}:      ${cyan}https://chat.test.localhost:8443/${reset}"
  echo "  ${green}DASHBOARD${reset}: ${cyan}https://dashboard.test.localhost:8443/${reset} (user: test, pass: testpass)"
  echo ""
  echo "Legacy HTTP access also available:"
  echo "  ${green}APP${reset}: ${cyan}http://localhost:5001${reset}"
  echo "  ${green}API${reset}: ${cyan}http://localhost:8001${reset}"
  echo "  ${green}CHAT${reset}: ${cyan}http://localhost:8507${reset}"
  echo "  ${green}PostgreSQL${reset}: ${cyan}localhost:5434${reset}"
  echo "  ${green}Redis${reset}: ${cyan}localhost:6380${reset}"
  echo ""
  echo "Test logs available at: ${cyan}$ICHRISBIRCH_HOME/test-logs/${reset}"
  echo "Use ${blue}ichrisbirch testing app-logs${reset} to view application logs"
  echo "Use ${blue}ichrisbirch testing logs${reset} to view Docker container logs"
  echo "Use ${blue}ichrisbirch testing health${reset} to run health checks"
}

function testing-stop() {
  cd "$ICHRISBIRCH_HOME" || exit
  echo "Stopping ${blue}TESTING${reset} environment"
  docker compose --project-name ichrisbirch-test -f docker-compose.yml -f docker-compose.test.yml down
}

function testing-restart() {
  cd "$ICHRISBIRCH_HOME" || exit
  echo "Restarting ${blue}TESTING${reset} environment"
  # Use 'up -d' instead of 'restart' to pick up any configuration changes
  docker compose --project-name ichrisbirch-test -f docker-compose.yml -f docker-compose.test.yml up -d
}

function testing-rebuild() {
  cd "$ICHRISBIRCH_HOME" || exit
  echo "Rebuilding and restarting ${blue}TESTING${reset} environment"
  docker compose --project-name ichrisbirch-test -f docker-compose.yml -f docker-compose.test.yml down
  docker compose --project-name ichrisbirch-test -f docker-compose.yml -f docker-compose.test.yml up -d --build
}

function testing-logs() {
  cd "$ICHRISBIRCH_HOME" || exit

  # Check for --json flag
  local json_mode=false
  local services=()
  for arg in "$@"; do
    if [[ "$arg" == "--json" ]]; then
      json_mode=true
    else
      services+=("$arg")
    fi
  done

  echo "Viewing ${blue}TESTING${reset} Docker container logs..."
  if [[ "$json_mode" == true ]]; then
    echo "Mode: ${cyan}JSON parsing${reset} (use without --json for console format)"
  fi
  echo ""

  # Build docker compose command
  local compose_cmd="docker compose --project-name ichrisbirch-test -f docker-compose.yml -f docker-compose.test.yml logs --follow --tail=50"
  if [[ ${#services[@]} -gt 0 ]]; then
    compose_cmd="$compose_cmd ${services[*]}"
  fi

  # Show live Docker Compose logs with appropriate formatting
  if [[ "$json_mode" == true ]]; then
    $compose_cmd | parse-json-logs | colored-logs
  else
    $compose_cmd | colored-logs
  fi
}

function testing-app-logs() {
  local lines="${1:-100}"
  local follow_flag=""

  # Check if --follow is passed as first or second argument
  if [[ "$1" == "--follow" ]] || [[ "$2" == "--follow" ]]; then
    follow_flag="--follow"
    # Adjust lines if --follow was passed as first argument
    if [[ "$1" == "--follow" ]]; then
      lines="${2:-100}"
    fi
  fi

  cd "$ICHRISBIRCH_HOME" || exit
  local test_logs_dir="$ICHRISBIRCH_HOME/test-logs"
  local log_file="$test_logs_dir/testing.log"

  # Check if test logs directory exists
  if [[ ! -d "$test_logs_dir" ]]; then
    echo "${red}Test logs directory not found: $test_logs_dir${reset}"
    echo "${cyan}Make sure the test environment has been started at least once:${reset}"
    echo "   ${blue}ichrisbirch testing start${reset}"
    return 1
  fi

  # Check if consolidated log file exists
  if [[ ! -f "$log_file" ]]; then
    echo "${red}Test log file not found: $log_file${reset}"
    echo "${cyan}Make sure the test environment is running to generate logs:${reset}"
    echo "   ${blue}ichrisbirch testing start${reset}"
    return 1
  fi

  echo "Viewing ${blue}TESTING${reset} application logs from: ${cyan}$log_file${reset}"

  if [[ -n "$follow_flag" ]]; then
    echo "   Mode: ${green}Follow${reset} (press Ctrl+C to exit)"
    echo ""
    tail -f "$log_file" | colored-logs
  else
    echo "   Lines: $lines"
    echo ""
    tail -n "$lines" "$log_file" | colored-logs
  fi
}

function testing-app-logs-follow() {
  testing-app-logs --follow
}

function testing-status() {
  cd "$ICHRISBIRCH_HOME" || exit
  echo "${blue}TESTING${reset} environment status:"
  echo ""

  # Show container status with colors
  docker compose --project-name ichrisbirch-test -f docker-compose.yml -f docker-compose.test.yml ps --format "table {{.Service}}\t{{.State}}\t{{.Ports}}" | colored-status

  echo ""
  echo "${blue}Test${reset} URLs:"
  echo "  • API:       https://api.test.localhost:8443/"
  echo "  • App:       https://app.test.localhost:8443/"
  echo "  • Chat:      https://chat.test.localhost:8443/"
  echo "  • Dashboard: https://dashboard.test.localhost:8443/ (user: test, pass: testpass)"
}

function testing-health() {
  echo "Running health check for ${blue}TESTING${reset} environment"

  cd "$ICHRISBIRCH_HOME" || exit

  if [ -x "./deploy-containers/traefik/scripts/health-check.sh" ]; then
    ./deploy-containers/traefik/scripts/health-check.sh test
  else
    echo "${red}Health check script not found${reset}"
    echo "Expected: ${cyan}./deploy-containers/traefik/scripts/health-check.sh${reset}"
    return 1
  fi
}

# Helper to load production environment variables from AWS SSM
function load-prod-env() {
  local aws_region="${AWS_REGION:-us-east-2}"
  local environment="production"

  get_ssm_param() {
    aws ssm get-parameter \
      --region "$aws_region" \
      --name "/ichrisbirch/$environment/$1" \
      --with-decryption \
      --query 'Parameter.Value' \
      --output text
  }

  export POSTGRES_PASSWORD
  POSTGRES_PASSWORD=$(get_ssm_param "postgres/password") || {
    echo "${red}Failed to fetch POSTGRES_PASSWORD from SSM${reset}"
    return 1
  }

  export REDIS_PASSWORD
  REDIS_PASSWORD=$(get_ssm_param "redis/password") || {
    echo "${red}Failed to fetch REDIS_PASSWORD from SSM${reset}"
    return 1
  }

  export DOMAIN="${DOMAIN:-ichrisbirch.com}"
}

function prod-start() {
  cd "$ICHRISBIRCH_HOME" || exit

  echo "Fetching secrets from AWS SSM..."
  load-prod-env || return 1
  echo "Secrets loaded for ${magenta}production${reset}"

  # Ensure proxy network exists for Traefik
  if ! docker network inspect proxy >/dev/null 2>&1; then
    echo "Creating external proxy network..."
    docker network create proxy
  fi

  echo "Starting ${magenta}PRODUCTION${reset} environment with ${green}Docker Compose + Traefik${reset}"
  echo "  (Cloudflare Tunnel handles external HTTPS)"
  docker compose --project-name ichrisbirch-prod -f docker-compose.yml up -d

  echo ""
  echo "Production environment started:"
  echo "  ${green}APP${reset}:  ${cyan}https://${DOMAIN}/${reset}"
  echo "  ${green}API${reset}:  ${cyan}https://api.${DOMAIN}/${reset}"
  echo "  ${green}CHAT${reset}: ${cyan}https://chat.${DOMAIN}/${reset}"
  echo ""
  echo "Use ${blue}ichrisbirch prod logs${reset} to view live container logs"
  echo "Use ${blue}ichrisbirch prod status${reset} to check service status"
  echo "Use ${blue}ichrisbirch prod health${reset} to run health checks"
}

function prod-stop() {
  cd "$ICHRISBIRCH_HOME" || exit
  load-prod-env || return 1
  echo "Stopping ${magenta}PRODUCTION${reset} environment"
  docker compose --project-name ichrisbirch-prod -f docker-compose.yml down
}

function prod-restart() {
  cd "$ICHRISBIRCH_HOME" || exit
  load-prod-env || return 1
  echo "Restarting ${magenta}PRODUCTION${reset} environment"
  # Use 'up -d' instead of 'restart' to pick up any configuration changes
  docker compose --project-name ichrisbirch-prod -f docker-compose.yml up -d
}

function prod-rebuild() {
  cd "$ICHRISBIRCH_HOME" || exit

  echo "Fetching secrets from AWS SSM..."
  load-prod-env || return 1

  echo "Rebuilding and restarting ${magenta}PRODUCTION${reset} environment"
  docker compose --project-name ichrisbirch-prod -f docker-compose.yml down
  docker compose --project-name ichrisbirch-prod -f docker-compose.yml up -d --build
}

function prod-monitor() {
  tmuxinator ichrisbirch-prod-monitoring
}

function prod-logs() {
  cd "$ICHRISBIRCH_HOME" || exit
  load-prod-env || return 1

  # Check for --json flag
  local json_mode=false
  local services=()
  for arg in "$@"; do
    if [[ "$arg" == "--json" ]]; then
      json_mode=true
    else
      services+=("$arg")
    fi
  done

  echo "Viewing ${magenta}PRODUCTION${reset} Docker container logs..."
  if [[ "$json_mode" == true ]]; then
    echo "Mode: ${cyan}JSON parsing${reset} (use without --json for console format)"
  fi
  echo ""

  # Build docker compose command
  local compose_cmd="docker compose --project-name ichrisbirch-prod -f docker-compose.yml logs --follow --tail=50"
  if [[ ${#services[@]} -gt 0 ]]; then
    compose_cmd="$compose_cmd ${services[*]}"
  fi

  # Show live Docker Compose logs with appropriate formatting
  if [[ "$json_mode" == true ]]; then
    $compose_cmd | parse-json-logs | colored-logs
  else
    $compose_cmd | colored-logs
  fi
}

function prod-status() {
  cd "$ICHRISBIRCH_HOME" || exit
  load-prod-env || return 1

  echo "${magenta}PRODUCTION${reset} environment status:"
  echo ""
  docker compose --project-name ichrisbirch-prod -f docker-compose.yml ps --format "table {{.Service}}\t{{.State}}\t{{.Ports}}" | colored-status

  echo ""
  echo "${magenta}Production${reset} URLs (via Cloudflare Tunnel):"
  echo "  • App:  https://${DOMAIN}/"
  echo "  • API:  https://api.${DOMAIN}/"
  echo "  • Chat: https://chat.${DOMAIN}/"
}

function prod-health() {
  echo "Running health check for ${magenta}PRODUCTION${reset} environment"

  cd "$ICHRISBIRCH_HOME" || exit

  if [ -x "./deploy-containers/traefik/scripts/health-check.sh" ]; then
    ./deploy-containers/traefik/scripts/health-check.sh prod
  else
    echo "${red}Health check script not found${reset}"
    echo "Expected: ${cyan}./deploy-containers/traefik/scripts/health-check.sh${reset}"
    return 1
  fi
}

function prod-apihealth() {
  curl --silent https://api.ichrisbirch.com/health/ | jq
}

# ============================================================================
# PROJECT STATS (Event-Sourced)
# ============================================================================

function stats-latest-file() {
  find "$ICHRISBIRCH_HOME/stats" -maxdepth 1 -name 'stats_*.json' -type f -printf '%T@ %p\n' 2>/dev/null | sort -rn | head -1 | cut -d' ' -f2-
}

function stats-usage() {
  echo "${green}Stats Commands${reset}"
  echo ""
  echo "  ${blue}stats summary${reset}       Dashboard with code, tests, quality, and activity"
  echo "  ${blue}stats code${reset}          Lines of code by language (live from tokei)"
  echo "  ${blue}stats tests${reset}         Test results, coverage, and slowest tests"
  echo "  ${blue}stats quality${reset}       Linter issues over 24h/7d/30d/all time"
  echo "  ${blue}stats activity [n]${reset}  Commit activity graph (default: 7 days)"
  echo "  ${blue}stats events [n]${reset}    Recent pre-commit hook events (default: 20)"
  echo "  ${blue}stats trends${reset}        Velocity, code churn, and test suite trends"
  echo "  ${blue}stats churn [n|all]${reset} File churn analysis (default: 30 days, 'all' for entire history)"
  echo "  ${blue}stats snapshot${reset}      Regenerate stats snapshot from events.jsonl"
  echo ""
  echo "Data sources:"
  echo "  • Code stats: Live from tokei"
  echo "  • Test/coverage: From last snapshot (updated on commit)"
  echo "  • Quality: From events.jsonl (pre-commit hook results)"
  echo "  • Activity: From events.jsonl commit events"
}

function stats-summary() {
  cd "$ICHRISBIRCH_HOME" || exit
  local stats_file
  stats_file=$(stats-latest-file)
  local events_file="$ICHRISBIRCH_HOME/stats/events/events.jsonl"

  echo "${green}Project Stats Summary${reset}"
  echo ""

  if [ -z "$stats_file" ] || [ ! -f "$stats_file" ]; then
    echo "${yellow}No stats snapshots found.${reset}"
    echo "Stats are collected automatically on each commit."
    return
  fi

  local collected_at
  collected_at=$(jq -r '.collected_at' "$stats_file" | cut -d'T' -f1)
  echo "Last collected: ${cyan}$collected_at${reset}"
  echo ""

  # Code stats (live from tokei) - show top 5 languages
  # Use max(code, comments) to handle prose languages (Markdown counts content as comments)
  local tokei_json total_loc
  tokei_json=$(tokei . --compact --output json 2>/dev/null)
  total_loc=$(echo "$tokei_json" | jq -r '[.[] | select(.code != null)] | map([.code, .comments] | max) | add // 0')

  echo "${blue}Code${reset}"
  echo "$tokei_json" | jq -r 'to_entries | map(select(.value.code != null and .key != "Total")) | sort_by(-([.value.code, .value.comments] | max)) | .[0:5] | .[] | "\(.key)\t\([.value.code, .value.comments] | max)\t\(.value.reports | length)"' | \
    while IFS=$'\t' read -r lang content files; do
      printf "  %-10s %'6d lines (%d files)\n" "$lang:" "$content" "$files"
    done
  printf "  ${cyan}%-10s %'6d lines${reset}\n" "Total:" "$total_loc"
  echo ""

  # Tests
  local tests_total tests_passed tests_failed coverage duration
  tests_total=$(jq -r '.tests.total // 0' "$stats_file")
  tests_passed=$(jq -r '.tests.passed // 0' "$stats_file")
  tests_failed=$(jq -r '.tests.failed // 0' "$stats_file")
  coverage=$(jq -r '.coverage.line_percent // 0' "$stats_file")
  duration=$(jq -r '.tests.duration_seconds // 0' "$stats_file" | cut -d'.' -f1)

  local pass_rate=0
  if [ "$tests_total" -gt 0 ]; then
    pass_rate=$((tests_passed * 100 / tests_total))
  fi

  echo "${blue}Tests${reset}"
  if [ "$tests_failed" -eq 0 ]; then
    printf "  Total:       %d tests (${green}%d%% pass${reset})\n" "$tests_total" "$pass_rate"
  else
    printf "  Total:       %d tests (${red}%d failed${reset})\n" "$tests_total" "$tests_failed"
  fi
  printf "  Coverage:    ${cyan}%.1f%%${reset}\n" "$coverage"
  printf "  Duration:    %ds\n" "$duration"
  echo ""

  # Dependencies
  local deps_direct deps_total
  deps_direct=$(jq -r '.dependencies.direct // 0' "$stats_file")
  deps_total=$(jq -r '.dependencies.total // 0' "$stats_file")

  echo "${blue}Dependencies${reset}"
  printf "  Direct:      %d packages\n" "$deps_direct"
  printf "  Total:       %d packages\n" "$deps_total"
  echo ""

  # Commit activity
  if [ -f "$events_file" ]; then
    local total_commits today_commits week_commits
    total_commits=$(grep -c '"type":"commit"' "$events_file" 2>/dev/null || echo 0)
    today_commits=$(grep '"type":"commit"' "$events_file" | grep -c "$(date +%Y-%m-%d)")

    local week_pattern
    week_pattern=$(for i in $(seq 0 6); do date -d "-${i} days" +%Y-%m-%d; done | paste -sd'|')
    week_commits=$(grep '"type":"commit"' "$events_file" | grep -cE "$week_pattern")

    echo "${blue}Activity${reset}"
    printf "  Today:       %d commits\n" "$today_commits"
    printf "  This week:   %d commits\n" "$week_commits"
    printf "  All time:    %d commits\n" "$total_commits"
  fi
}

function stats-snapshot() {
  cd "$ICHRISBIRCH_HOME" || exit
  uv run python -m stats.snapshot
}

function stats-code() {
  cd "$ICHRISBIRCH_HOME" || exit

  echo "${green}Code Statistics by Language${reset}"
  echo ""

  printf "${cyan}%-15s %10s %10s %8s${reset}\n" "Language" "Content" "Blanks" "Files"
  echo "---------------------------------------------------"

  # Run tokei directly for real-time stats
  # For code: content = code, for prose (Markdown): content = comments
  # We use max(code, comments) as content to handle both properly
  local tokei_json
  tokei_json=$(tokei . --compact --output json 2>/dev/null)

  echo "$tokei_json" | \
    jq -r 'to_entries | map(select(.value.code != null and .key != "Total")) | sort_by(-([.value.code, .value.comments] | max)) | .[] | [.key, ([.value.code, .value.comments] | max), .value.blanks, (.value.reports | length)] | @tsv' | \
    while IFS=$'\t' read -r lang content blanks files; do
      printf "%-15s %'10d %'10d %8d\n" "$lang" "$content" "$blanks" "$files"
    done

  echo "---------------------------------------------------"
  local total_content total_blanks
  total_content=$(echo "$tokei_json" | jq -r '[.[] | select(.code != null)] | map([.code, .comments] | max) | add')
  total_blanks=$(echo "$tokei_json" | jq -r '[.[] | select(.code != null)] | map(.blanks) | add')
  printf "${green}%-15s %'10d %'10d${reset}\n" "Total" "$total_content" "$total_blanks"
}

function stats-tests() {
  cd "$ICHRISBIRCH_HOME" || exit
  local stats_file
  stats_file=$(stats-latest-file)

  echo "${green}Test Statistics${reset}"
  echo ""

  if [ -z "$stats_file" ] || [ ! -f "$stats_file" ]; then
    echo "${yellow}No stats snapshots found.${reset}"
    return
  fi

  local total passed failed skipped errors duration coverage
  total=$(jq -r '.tests.total // 0' "$stats_file")
  passed=$(jq -r '.tests.passed // 0' "$stats_file")
  failed=$(jq -r '.tests.failed // 0' "$stats_file")
  skipped=$(jq -r '.tests.skipped // 0' "$stats_file")
  errors=$(jq -r '.tests.errors // 0' "$stats_file")
  duration=$(jq -r '.tests.duration_seconds // 0' "$stats_file")
  coverage=$(jq -r '.coverage.line_percent // 0' "$stats_file")

  echo "${blue}Results${reset}"
  printf "  Total:     %d\n" "$total"
  printf "  Passed:    ${green}%d${reset}\n" "$passed"
  [ "$failed" -gt 0 ] && printf "  Failed:    ${red}%d${reset}\n" "$failed"
  [ "$skipped" -gt 0 ] && printf "  Skipped:   ${yellow}%d${reset}\n" "$skipped"
  [ "$errors" -gt 0 ] && printf "  Errors:    ${red}%d${reset}\n" "$errors"
  echo ""

  echo "${blue}Performance${reset}"
  printf "  Duration:  %.1fs\n" "$duration"
  printf "  Coverage:  %.1f%%\n" "$coverage"
  echo ""

  echo "${blue}Slowest Tests${reset}"
  jq -r '.tests.slowest[:5] | .[] | "  " + (.duration | tostring | .[0:5]) + "s  " + .name' "$stats_file" | \
    sed 's|tests/ichrisbirch/||g' | sed 's|::test_|: |g'
}

function stats-quality() {
  cd "$ICHRISBIRCH_HOME" || exit
  local events_file="$ICHRISBIRCH_HOME/stats/events/events.jsonl"

  echo "${green}Code Quality - Pre-commit Hook Results${reset}"
  echo ""

  if [ ! -f "$events_file" ]; then
    echo "${yellow}No events file found.${reset}"
    return
  fi

  # Date patterns for filtering
  local today
  today=$(date +%Y-%m-%d)

  printf "${cyan}%-18s %6s %6s %6s %6s${reset}\n" "Tool" "24h" "7d" "30d" "All"
  echo "----------------------------------------------------"

  local tools=("ruff" "mypy" "bandit" "shellcheck" "codespell" "detect-private-key")

  # Map tools to their issue field names (different hooks use different fields)
  get_issue_field() {
    case "$1" in
      mypy) echo ".errors" ;;
      shellcheck) echo ".comments" ;;
      *) echo ".issues" ;;
    esac
  }

  for tool in "${tools[@]}"; do
    local issues_today issues_7d issues_30d issues_all
    local field
    field=$(get_issue_field "$tool")

    # Count issues for each time period
    issues_today=$(grep "\"type\":\"hook.$tool\"" "$events_file" | grep "$today" | jq -s "[.[]$field | length] | add // 0")
    issues_7d=$(grep "\"type\":\"hook.$tool\"" "$events_file" | grep -E "$(for i in $(seq 0 6); do date -d "-${i} days" +%Y-%m-%d; done | paste -sd'|')" | jq -s "[.[]$field | length] | add // 0")
    issues_30d=$(grep "\"type\":\"hook.$tool\"" "$events_file" | grep -E "$(for i in $(seq 0 29); do date -d "-${i} days" +%Y-%m-%d; done | paste -sd'|')" | jq -s "[.[]$field | length] | add // 0")
    issues_all=$(grep "\"type\":\"hook.$tool\"" "$events_file" | jq -s "[.[]$field | length] | add // 0")

    # Format with colors - use fixed width padding after color codes
    local c_today c_7d c_30d c_all
    if [ "$issues_today" -eq 0 ]; then
      c_today="${gray}     0${reset}"
    else
      c_today="${yellow}$(printf '%6d' "$issues_today")${reset}"
    fi
    if [ "$issues_7d" -eq 0 ]; then
      c_7d="${gray}     0${reset}"
    else
      c_7d="${yellow}$(printf '%6d' "$issues_7d")${reset}"
    fi
    if [ "$issues_30d" -eq 0 ]; then
      c_30d="${gray}     0${reset}"
    else
      c_30d="${yellow}$(printf '%6d' "$issues_30d")${reset}"
    fi
    if [ "$issues_all" -eq 0 ]; then
      c_all="${gray}     0${reset}"
    else
      c_all="$(printf '%6d' "$issues_all")"
    fi

    printf "%-18s %s %s %s %s\n" "$tool" "$c_today" "$c_7d" "$c_30d" "$c_all"
  done

  echo ""

  # Show hook run counts with fail percentages across time periods
  echo "${blue}Hook Runs${reset}"
  printf "${cyan}%-10s %7s %7s %12s${reset}\n" "Period" "Runs" "Fail%" "vs Today"
  echo "----------------------------------------"

  # Helper function to get date pattern for a range
  get_date_pattern() {
    local days=$1
    for i in $(seq 0 $((days - 1))); do
      date -d "-${i} days" +%Y-%m-%d
    done | paste -sd'|'
  }

  # Calculate stats for each period
  local periods=("1" "7" "14" "30" "60" "90")
  local labels=("Today" "Last 7d" "Last 14d" "Last 30d" "Last 60d" "Last 90d")
  local today_pct=""

  for i in "${!periods[@]}"; do
    local days=${periods[$i]}
    local label=${labels[$i]}
    local pattern runs failed pct

    if [ "$days" -eq 1 ]; then
      pattern="$today"
    else
      pattern=$(get_date_pattern "$days")
    fi

    runs=$(grep '"type":"hook\.' "$events_file" | grep -cE "$pattern" || echo 0)
    failed=$(grep '"type":"hook\.' "$events_file" | grep -E "$pattern" | grep -c '"status":"failed"' || echo 0)

    if [ "$runs" -gt 0 ]; then
      pct=$(echo "scale=1; $failed * 100 / $runs" | bc)
    else
      pct="0"
    fi

    # Store today's percentage for comparison
    if [ "$days" -eq 1 ]; then
      today_pct="$pct"
      printf "%-10s %7d %6s%%\n" "$label" "$runs" "$pct"
    else
      # Calculate percentage change: how that period compares to today
      # Positive = that period was worse (higher fail rate) than today
      # Negative = that period was better (lower fail rate) than today
      local change_str=""
      if [ "$runs" -gt 0 ] && [ "$(echo "$today_pct > 0" | bc)" -eq 1 ]; then
        local change
        change=$(echo "scale=1; ($pct - $today_pct) * 100 / $today_pct" | bc)
        if [ "$(echo "$change > 0" | bc)" -eq 1 ]; then
          # Period was worse than today (higher fail rate)
          change_str="${red}$(printf '↑%6.1f%%' "$change")${reset}"
        elif [ "$(echo "$change < 0" | bc)" -eq 1 ]; then
          # Period was better than today (lower fail rate)
          change_str="${green}$(printf '↓%6.1f%%' "${change#-}")${reset}"
        else
          change_str="${gray}     --  ${reset}"
        fi
      elif [ "$(echo "$pct > 0" | bc)" -eq 1 ]; then
        # Period had failures but today has 0%
        change_str="${red}$(printf '↑%6.1f%%' "$pct")${reset}"
      else
        change_str="${gray}     --  ${reset}"
      fi
      printf "%-10s %7d %6s%% %b\n" "$label" "$runs" "$pct" "$change_str"
    fi
  done

  echo ""
  echo "${gray}Note: Issues shown are from all pre-commit runs (including failed commits)${reset}"
}

function stats-activity() {
  cd "$ICHRISBIRCH_HOME" || exit
  local days="${1:-7}"
  local events_file="$ICHRISBIRCH_HOME/stats/events/events.jsonl"

  echo "${green}Commit Activity (last $days days)${reset}"
  echo ""

  if [ ! -f "$events_file" ]; then
    echo "${yellow}No events file found.${reset}"
    return
  fi

  for i in $(seq 0 $((days - 1))); do
    local date_str day_name
    date_str=$(date -d "-${i} days" +%Y-%m-%d)
    day_name=$(date -d "-${i} days" +%a)

    local count
    count=$(grep '"type":"commit"' "$events_file" | grep -c "$date_str")

    local bar=""
    for ((j = 0; j < count && j < 20; j++)); do
      bar="${bar}#"
    done
    [ "$count" -gt 20 ] && bar="${bar}+"

    if [ "$i" -eq 0 ]; then
      printf "${cyan}%-10s${reset} %-3s  ${green}%-20s${reset} %d\n" "$date_str" "$day_name" "$bar" "$count"
    else
      printf "%-10s %-3s  ${green}%-20s${reset} %d\n" "$date_str" "$day_name" "$bar" "$count"
    fi
  done

  echo ""
  local total_week
  total_week=$(grep -c '"type":"commit"' "$events_file")
  echo "Total recorded commits: $total_week"
}

function stats-events() {
  cd "$ICHRISBIRCH_HOME" || exit
  local count="${1:-20}"
  local events_file="$ICHRISBIRCH_HOME/stats/events/events.jsonl"

  echo "${green}Recent Events (last $count)${reset}"
  echo ""

  if [ -f "$events_file" ]; then
    tail -n "$count" "$events_file" | jq -r '
      def info:
        if .type == "commit" then [.short_hash, ""]
        elif .type == "collect.tokei" then [(.total_files | tostring), "files"]
        elif .type == "collect.pytest" then [(.summary.total | tostring), "tests"]
        elif .type == "collect.coverage" then ["\(.summary.percent_covered | floor)%", "coverage"]
        elif .type == "collect.docker" then [(.containers | length | tostring), "containers"]
        elif .type == "collect.dependencies" then [(.total_count | tostring), "pkgs"]
        elif .type == "collect.files" then [(.total_files | tostring), "files"]
        elif .type == "collect.radon" then [(.avg_complexity | floor | tostring), "avg_complexity"]
        elif .status then [.status, ""]
        else ["-", ""]
        end;
      "\(.type)\t\(.timestamp[11:19])\t\(info[0])\t\(info[1])"
    ' | while IFS=$'\t' read -r type time value label; do
      printf "%-30s  %s  %6s  %s\n" "$type" "$time" "$value" "$label"
    done
  else
    echo "${yellow}No events file found.${reset}"
  fi
}

function stats-churn() {
  cd "$ICHRISBIRCH_HOME" || exit
  local arg="${1:-30}"

  if [ "$arg" = "all" ]; then
    stats-churn-all
    return
  fi

  local days="$arg"
  echo "${green}Code Churn Analysis (last $days days)${reset}"
  echo ""

  # Most frequently modified files (exclude .lock files)
  echo "${blue}Most Modified Files${reset}"
  git log --since="$days days ago" --name-only --pretty=format: 2>/dev/null | \
    grep -v '^$' | grep -v '\.lock$' | sort | uniq -c | sort -rn | head -10 | \
    while read -r count file; do
      printf "  %4d changes  %s\n" "$count" "$file"
    done
  echo ""

  # Files with most lines changed (exclude .lock files)
  echo "${blue}Most Lines Changed${reset}"
  git log --since="$days days ago" --numstat --pretty=format: 2>/dev/null | \
    awk 'NF==3 && $1 != "-" && $3 !~ /\.lock$/ {adds[$3]+=$1; dels[$3]+=$2} END {for(f in adds) print adds[f]+dels[f], adds[f], dels[f], f}' | \
    sort -rn | head -10 | \
    while read -r total added deleted file; do
      printf "  %5d lines  ${green}+%-5d${reset} ${red}-%-5d${reset}  %s\n" "$total" "$added" "$deleted" "$file"
    done
  echo ""

  # Recently created files (exclude .lock files)
  echo "${blue}Recently Created Files${reset}"
  git log --since="$days days ago" --diff-filter=A --name-only --pretty=format: 2>/dev/null | \
    grep -v '^$' | grep -v '\.lock$' | sort -u | tail -10 | \
    while read -r file; do
      if [ -f "$file" ]; then
        printf "  ${green}+${reset} %s\n" "$file"
      fi
    done
  echo ""

  # Recently deleted files (exclude .lock files)
  echo "${blue}Recently Deleted Files${reset}"
  git log --since="$days days ago" --diff-filter=D --name-only --pretty=format: 2>/dev/null | \
    grep -v '^$' | grep -v '\.lock$' | sort -u | tail -10 | \
    while read -r file; do
      printf "  ${red}-${reset} %s\n" "$file"
    done
  echo ""

  # Churn by directory (2 levels deep, only include actual directories)
  echo "${blue}Churn by Directory${reset}"
  git log --since="$days days ago" --name-only --pretty=format: 2>/dev/null | \
    grep -v '^$' | grep '/' | \
    awk -F'/' 'NF>=3 {print $1"/"$2}' | \
    sort | uniq -c | sort -rn | head -10 | \
    while read -r count dir; do
      printf "  %4d changes  %s/\n" "$count" "$dir"
    done
}

function stats-churn-all() {
  cd "$ICHRISBIRCH_HOME" || exit

  local total_commits
  total_commits=$(git rev-list --count HEAD 2>/dev/null || echo "0")
  local first_commit_date
  first_commit_date=$(git log --reverse --format="%cs" | head -1)

  echo "${green}Code Churn Analysis (all time - $total_commits commits since $first_commit_date)${reset}"
  echo ""

  # Most frequently modified files (exclude .lock files)
  echo "${blue}Most Modified Files${reset}"
  git log --name-only --pretty=format: 2>/dev/null | \
    grep -v '^$' | grep -v '\.lock$' | sort | uniq -c | sort -rn | head -15 | \
    while read -r count file; do
      printf "  %5d changes  %s\n" "$count" "$file"
    done
  echo ""

  # Files with most lines changed (exclude .lock files)
  echo "${blue}Most Lines Changed${reset}"
  git log --numstat --pretty=format: 2>/dev/null | \
    awk 'NF==3 && $1 != "-" && $3 !~ /\.lock$/ {adds[$3]+=$1; dels[$3]+=$2} END {for(f in adds) print adds[f]+dels[f], adds[f], dels[f], f}' | \
    sort -rn | head -15 | \
    while read -r total added deleted file; do
      printf "  %6d lines  ${green}+%-6d${reset} ${red}-%-6d${reset}  %s\n" "$total" "$added" "$deleted" "$file"
    done
  echo ""

  # Churn by directory (2 levels deep, only include actual directories)
  echo "${blue}Churn by Directory${reset}"
  git log --name-only --pretty=format: 2>/dev/null | \
    grep -v '^$' | grep '/' | \
    awk -F'/' 'NF>=3 {print $1"/"$2}' | \
    sort | uniq -c | sort -rn | head -15 | \
    while read -r count dir; do
      printf "  %5d changes  %s/\n" "$count" "$dir"
    done

}

function stats-trends() {
  cd "$ICHRISBIRCH_HOME" || exit

  echo "${green}Project Trends${reset}"
  echo ""

  # Get commit counts for different periods
  echo "${blue}Commit Velocity${reset}"
  local today_commits week_commits month_commits prev_week prev_month
  today_commits=$(git log --oneline --since="24 hours ago" 2>/dev/null | wc -l | tr -d ' ')
  week_commits=$(git log --oneline --since="7 days ago" 2>/dev/null | wc -l | tr -d ' ')
  month_commits=$(git log --oneline --since="30 days ago" 2>/dev/null | wc -l | tr -d ' ')
  prev_week=$(git log --oneline --since="14 days ago" --until="7 days ago" 2>/dev/null | wc -l | tr -d ' ')
  prev_month=$(git log --oneline --since="60 days ago" --until="30 days ago" 2>/dev/null | wc -l | tr -d ' ')

  printf "  %-14s %d commits\n" "Today:" "$today_commits"
  printf "  %-14s %d commits" "Last 7 days:" "$week_commits"
  if [ "$prev_week" -gt 0 ]; then
    local change=$(( (week_commits - prev_week) * 100 / prev_week ))
    if [ "$change" -gt 0 ]; then
      printf " (${green}↑%d%%${reset} vs prev week's %d)\n" "$change" "$prev_week"
    elif [ "$change" -lt 0 ]; then
      printf " (${red}↓%d%%${reset} vs prev week's %d)\n" "$((-change))" "$prev_week"
    else
      printf " (same as prev week)\n"
    fi
  else
    printf "\n"
  fi
  printf "  %-14s %d commits\n" "Last 30 days:" "$month_commits"
  echo ""

  # Code changes from git
  echo "${blue}Code Churn (lines changed)${reset}"
  local week_added week_deleted month_added month_deleted
  week_added=$(git log --since="7 days ago" --numstat --pretty="" 2>/dev/null | awk '{s+=$1} END {print s+0}')
  week_deleted=$(git log --since="7 days ago" --numstat --pretty="" 2>/dev/null | awk '{s+=$2} END {print s+0}')
  month_added=$(git log --since="30 days ago" --numstat --pretty="" 2>/dev/null | awk '{s+=$1} END {print s+0}')
  month_deleted=$(git log --since="30 days ago" --numstat --pretty="" 2>/dev/null | awk '{s+=$2} END {print s+0}')

  printf "  %-14s ${green}+%'d${reset} / ${red}-%'d${reset}\n" "Last 7 days:" "$week_added" "$week_deleted"
  printf "  %-14s ${green}+%'d${reset} / ${red}-%'d${reset}\n" "Last 30 days:" "$month_added" "$month_deleted"
  echo ""

  # Test and coverage from latest stats snapshot
  echo "${blue}Test Suite (from latest snapshot)${reset}"
  local stats_dir="$ICHRISBIRCH_HOME/stats"
  local latest_stats
  latest_stats=$(find "$stats_dir" -maxdepth 1 -name 'stats_*.json' -type f -printf '%T@ %p\n' 2>/dev/null | sort -rn | head -1 | cut -d' ' -f2-)

  if [ -n "$latest_stats" ]; then
    local curr_tests curr_passed curr_failed curr_cov curr_dur
    curr_tests=$(jq -r '.tests.total // 0' "$latest_stats")
    curr_passed=$(jq -r '.tests.passed // 0' "$latest_stats")
    curr_failed=$(jq -r '.tests.failed // 0' "$latest_stats")
    curr_cov=$(jq -r '.coverage.line_percent // 0' "$latest_stats")
    curr_dur=$(jq -r '.tests.duration_seconds // 0' "$latest_stats")

    printf "  %-14s %d tests" "Total:" "$curr_tests"
    if [ "$curr_failed" -gt 0 ]; then
      printf " (%s%d failed%s)\n" "$red" "$curr_failed" "$reset"
    else
      printf " (%sall passing%s)\n" "$green" "$reset"
    fi
    if [ "$(echo "$curr_cov > 0" | bc)" -eq 1 ]; then
      printf "  %-14s %.1f%%\n" "Coverage:" "$curr_cov"
    else
      printf "  %-14s %snot collected%s\n" "Coverage:" "$gray" "$reset"
    fi
    printf "  %-14s %.0fs\n" "Duration:" "$curr_dur"
  else
    printf "  %sNo stats snapshots found%s\n" "$gray" "$reset"
  fi
  echo ""

  # Python LOC trend
  echo "${blue}Python LOC (from git)${reset}"
  local py_week_added py_week_deleted py_month_added py_month_deleted
  py_week_added=$(git log --since="7 days ago" --numstat --pretty="" -- '*.py' 2>/dev/null | awk '{s+=$1} END {print s+0}')
  py_week_deleted=$(git log --since="7 days ago" --numstat --pretty="" -- '*.py' 2>/dev/null | awk '{s+=$2} END {print s+0}')
  py_month_added=$(git log --since="30 days ago" --numstat --pretty="" -- '*.py' 2>/dev/null | awk '{s+=$1} END {print s+0}')
  py_month_deleted=$(git log --since="30 days ago" --numstat --pretty="" -- '*.py' 2>/dev/null | awk '{s+=$2} END {print s+0}')

  local py_week_net=$((py_week_added - py_week_deleted))
  local py_month_net=$((py_month_added - py_month_deleted))

  if [ "$py_week_net" -ge 0 ]; then
    printf "  %-14s ${green}+%'d${reset} net (${green}+%'d${reset}/${red}-%'d${reset})\n" "Last 7 days:" "$py_week_net" "$py_week_added" "$py_week_deleted"
  else
    printf "  %-14s ${red}%'d${reset} net (${green}+%'d${reset}/${red}-%'d${reset})\n" "Last 7 days:" "$py_week_net" "$py_week_added" "$py_week_deleted"
  fi
  if [ "$py_month_net" -ge 0 ]; then
    printf "  %-14s ${green}+%'d${reset} net (${green}+%'d${reset}/${red}-%'d${reset})\n" "Last 30 days:" "$py_month_net" "$py_month_added" "$py_month_deleted"
  else
    printf "  %-14s ${red}%'d${reset} net (${green}+%'d${reset}/${red}-%'d${reset})\n" "Last 30 days:" "$py_month_net" "$py_month_added" "$py_month_deleted"
  fi
  echo ""

  # Hot files (modified multiple times in last 7 days)
  echo "${blue}Hot Files (7 days)${reset}"
  git log --since="7 days ago" --name-only --pretty=format: 2>/dev/null | \
    grep -v '^$' | sort | uniq -c | sort -rn | head -5 | \
    while read -r count file; do
      if [ "$count" -gt 1 ]; then
        printf "  %2dx  %s\n" "$count" "$file"
      fi
    done
  echo ""

  # Activity chart (30 days) - vertical bar chart
  echo "${blue}Daily Commits (30 days)${reset}"
  local max_day=0
  declare -a day_counts
  for i in $(seq 29 -1 0); do
    local d
    d=$(date -d "-${i} days" +%Y-%m-%d)
    local cnt
    cnt=$(git log --oneline --since="$d 00:00:00" --until="$d 23:59:59" 2>/dev/null | wc -l | tr -d ' ')
    day_counts[i]=$cnt
    [ "$cnt" -gt "$max_day" ] && max_day=$cnt
  done

  # Print 10 rows (top to bottom)
  for row in $(seq 10 -1 1); do
    printf "  "
    local threshold=$(( (row * max_day) / 10 ))
    for i in $(seq 29 -1 0); do
      local cnt=${day_counts[i]}
      if [ "$cnt" -ge "$threshold" ]; then
        printf "%s███%s" "$green" "$reset"
      else
        printf "   "
      fi
    done
    printf "\n"
  done
  # Print day-of-week labels
  printf "  %s" "$green"
  for i in $(seq 29 -1 0); do
    local dow
    dow=$(date -d "-${i} days" +%a | cut -c1)
    printf " %s " "$dow"
  done
  printf "%s\n" "$reset"
  echo ""

  # Commit time distribution (hour of day) - vertical bar chart
  echo "${blue}Commit Time of Day (30 days)${reset}"
  local hour_counts=()
  for h in $(seq 0 23); do
    hour_counts[h]=0
  done
  local max_hour=1
  while read -r hour; do
    [ -n "$hour" ] && ((hour_counts[10#$hour]++))
    [ "${hour_counts[10#$hour]}" -gt "$max_hour" ] && max_hour=${hour_counts[10#$hour]}
  done < <(git log --since="30 days ago" --date=format:%H --format="%ad" 2>/dev/null)

  # Print 10 rows (top to bottom)
  for row in $(seq 10 -1 1); do
    printf "  "
    local threshold=$(( (row * max_hour) / 10 ))
    for h in $(seq 0 23); do
      local cnt=${hour_counts[$h]:-0}
      if [ "$cnt" -ge "$threshold" ]; then
        printf "%s███%s" "$cyan" "$reset"
      else
        printf "   "
      fi
    done
    printf "\n"
  done
  printf "  %s" "$cyan"
  for h in $(seq 0 23); do
    printf "%-3d" "$h"
  done
  printf "%s\n" "$reset"
}

function usage() {
  echo "${yellow}           _                  _                  _       ${reset}"
  echo "${yellow}  (*)     |=|         (*)    |=|   (*)          |=|      ${reset}"
  echo "${yellow}   _  ____|=| _   ____ _  ___|=| _  _  ____ ____|=| _    ${reset}"
  echo "${yellow}  |=|/ ___)=|| =\/ ___)=|/___)=|| \|=|/ ___) ___)=|| =\  ${reset}"
  echo "${yellow}  |=(=(___|=| |=|=|   |=|___ |=|_)=)=|=|  (=(___|=| |=|  ${reset}"
  echo "${yellow}  |_|\____)_| |_|_|   |_(___/|____/|_|_|   \____)_| |_|  ${reset}"
  echo
  echo "${green}Core Commands:${reset}"
  echo "  ${blue}open${reset}      - Launch VS Code and create tmux session for development"
  echo "  ${blue}cd${reset}        - Navigate to project directory and activate Python virtual environment"
  echo "  ${blue}logs${reset}      - List log files in configured log directory"
  echo "  ${blue}test run${reset}  - Execute pytest (supports paths and args, see below)"
  echo "  ${blue}ssl-manager <action> [env]${reset} - Manage SSL certificates for HTTPS"
  echo "    • ${yellow}Actions${reset}: generate, validate, info"
  echo "    • ${yellow}Environments${reset}: dev, test, prod, all"
  echo "    • ${yellow}Examples${reset}: ${cyan}ssl-manager generate dev${reset}, ${cyan}ssl-manager info all${reset}"
  echo
  echo "${green}Development Environment (HTTPS with Traefik):${reset}"
  echo "  ${blue}dev start${reset}     - Start development services with HTTPS (api.docker.localhost, app.docker.localhost, etc.)"
  echo "  ${blue}dev stop${reset}      - Stop all development services and remove containers"
  echo "  ${blue}dev restart${reset}   - Restart existing containers without rebuilding images (quick recovery from crashes)"
  echo "  ${blue}dev rebuild${reset}   - Stop services, rebuild Docker images, and restart (use after code/dependency changes)"
  echo "  ${blue}dev logs [--json] [service]${reset} - View live Docker container logs"
  echo "    • ${yellow}--json${reset}: Parse JSON structlog output for human-readable display"
  echo "    • ${yellow}service${reset}: Optional service name to filter (api, app, chat, scheduler)"
  echo "  ${blue}dev status${reset}    - Display container status and service URLs"
  echo "  ${blue}dev health${reset}    - Run comprehensive health checks for all services"
  echo
  echo "${green}Test Environment (HTTPS with Traefik - runs alongside dev):${reset}"
  echo "  ${blue}testing start${reset}   - Start isolated test services with HTTPS (api.test.localhost:8443, etc.)"
  echo "  ${blue}testing stop${reset}    - Stop test environment services"
  echo "  ${blue}testing restart${reset} - Restart test containers without rebuilding"
  echo "  ${blue}testing rebuild${reset} - Rebuild and restart test environment"
  echo "  ${blue}testing logs [--json] [service]${reset} - View live test container logs"
  echo "    • ${yellow}--json${reset}: Parse JSON structlog output for human-readable display"
  echo "  ${blue}testing status${reset}  - Display test container status and service URLs"
  echo "  ${blue}testing health${reset}  - Run comprehensive health checks for test services"
  echo "  ${blue}testing app-logs [lines] [--follow]${reset} - View consolidated application logs from testing.log"
  echo "    • ${yellow}lines${reset}: number of lines to show (default: 100)"
  echo "    • ${yellow}--follow${reset}: follow logs in real-time"
  echo "    • Examples: ${cyan}testing app-logs${reset}, ${cyan}testing app-logs 50${reset}, ${cyan}testing app-logs --follow${reset}"
  echo "  ${blue}testing app-logs-follow${reset} - Follow consolidated application logs in real-time"
  echo "  ${blue}test run [path] [args]${reset} - Execute pytest with test environment"
  echo "    • No args: run all tests"
  echo "    • With path: run specific test file or directory"
  echo "    • Examples: ${cyan}test run${reset}, ${cyan}test run tests/ichrisbirch/app/test_login.py -v${reset}"
  echo "  ${blue}test cov [path] [args]${reset} - Run pytest with coverage report"
  echo "    • Generates HTML coverage report in htmlcov/"
  echo
  echo "${green}Production Environment (Cloudflare Tunnel + Traefik):${reset}"
  echo "  ${blue}prod start${reset}     - Fetch SSM secrets and start production services"
  echo "  ${blue}prod stop${reset}      - Stop production services and remove containers"
  echo "  ${blue}prod restart${reset}   - Restart existing production containers without rebuilding"
  echo "  ${blue}prod rebuild${reset}   - Fetch SSM secrets, rebuild Docker images, and restart"
  echo "  ${blue}prod logs [--json] [service]${reset} - View production Docker container logs"
  echo "    • ${yellow}--json${reset}: Parse JSON structlog output for human-readable display"
  echo "  ${blue}prod status${reset}    - Check production service status and URLs"
  echo "  ${blue}prod health${reset}    - Run comprehensive health checks for production services"
  echo "  ${blue}prod apihealth${reset} - HTTP health check against production API endpoint"
  echo
  echo "${green}Project Stats:${reset}"
  echo "  ${blue}stats${reset}               - Show stats submenu"
  echo "  ${blue}stats summary${reset}       - Dashboard with code, tests, quality, and activity"
  echo
  echo "${green}Service URLs:${reset}"
  echo "  ${blue}Development${reset}: https://api.docker.localhost, https://app.docker.localhost, https://chat.docker.localhost"
  echo "  ${blue}Test${reset}:        https://api.test.localhost:8443, https://app.test.localhost:8443"
  echo "  ${blue}Production${reset}:  https://api.ichrisbirch.com, https://app.ichrisbirch.com (via Cloudflare Tunnel)"
  echo
  echo "${green}Technical Notes:${reset}"
  echo "  • Development/test use Traefik with local certificates for HTTPS"
  echo "  • Production uses Cloudflare Tunnel for HTTPS (Traefik receives HTTP internally)"
  echo "  • Development and test environments run simultaneously on different ports"
  echo "  • Production secrets fetched from AWS SSM Parameter Store"
  echo "  • Use ${blue}<env> health${reset} commands for comprehensive service validation"
}
# check if the first argument is empty and print usage if so
if [ -z "$1" ]; then
  usage
  exit 0
fi

case $1 in
help | -h | --help | -help)
  usage
  ;;
install)
  install
  ;;
open)
  open
  ;;
cd)
  project-cd
  ;;
logs)
  logs
  ;;
test)
  # Pass remaining arguments to test function (e.g., test run path/to/test.py -v)
  subcmd="$2"
  shift 2  # Remove 'ichrisbirch' and 'test' (note: $1 is 'test', $2 is subcommand)
  test-"$subcmd" "$@"
  ;;
testing)
  case "$2" in
  app-logs)
    # Handle app-logs with lines and --follow options
    testing-app-logs "$3" "$4"
    ;;
  app-logs-follow)
    # Simplified follow function
    testing-app-logs-follow
    ;;
  health)
    testing-health
    ;;
  logs)
    shift 2
    testing-logs "$@"
    ;;
  *)
    # Default testing command pattern
    testing-"$2"
    ;;
  esac
  ;;
dev)
  case "$2" in
  health)
    dev-health
    ;;
  logs)
    shift 2
    dev-logs "$@"
    ;;
  *)
    dev-"$2"
    ;;
  esac
  ;;
prod)
  case "$2" in
  health)
    prod-health
    ;;
  logs)
    shift 2
    prod-logs "$@"
    ;;
  *)
    prod-"$2"
    ;;
  esac
  ;;
ssl-manager)
  ssl-manager "$2" "$3"
  ;;
stats)
  case "$2" in
  "")
    stats-usage
    ;;
  summary)
    stats-summary
    ;;
  code)
    stats-code
    ;;
  tests)
    stats-tests
    ;;
  quality)
    stats-quality
    ;;
  activity)
    stats-activity "$3"
    ;;
  events)
    stats-events "$3"
    ;;
  trends)
    stats-trends
    ;;
  churn)
    stats-churn "$3"
    ;;
  snapshot)
    stats-snapshot
    ;;
  *)
    echo "${red}Unknown stats command: $2${reset}"
    echo ""
    stats-usage
    ;;
  esac
  ;;
*)
  echo "${red}!! '$1' is not a valid ichrisbirch command !!${reset}"
  echo ""
  usage
  ;;
esac
