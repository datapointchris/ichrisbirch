#!/usr/bin/env bash
# shellcheck shell=bash
# shellcheck disable=SC2034

ICHRISBIRCH_HOME="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && git rev-parse --show-toplevel)"

if [[ $(uname) == "Darwin" ]]; then
  LOG_DIR="/usr/local/var/log/ichrisbirch"
else
  LOG_DIR="/var/log/ichrisbirch"
fi

export LOG_DIR

red=$(tput setaf 1)
green=$(tput setaf 2)
yellow=$(tput setaf 3)
blue=$(tput setaf 4)
magenta=$(tput setaf 5)
cyan=$(tput setaf 6)
white=$(tput setaf 7)
gray=$(tput setaf 8)
bright_red=$(tput setaf 9)
bright_green=$(tput setaf 10)
bright_yellow=$(tput setaf 11)
bright_blue=$(tput setaf 12)
bright_magenta=$(tput setaf 13)
bright_cyan=$(tput setaf 14)
orange=$(tput setaf 208) # 256-color orange
reset=$(tput sgr0)

function colored-logs() {
  local RED_ERROR="${red}[ERROR]${reset}"
  local YELLOW_WARNING="${yellow}[WARNING]${reset}"
  local BLUE_INFO="${blue}[INFO]${reset}"
  local GREEN_DEBUG="${green}[DEBUG]${reset}"
  local MAGENTA_CRITICAL="${magenta}[CRITICAL]${reset}"

  # Service name colors
  local RED_REDIS="${red}redis${reset}"
  local GREEN_POSTGRES="${green}postgres${reset}"
  local CYAN_NGINX="${cyan}nginx${reset}"
  local BRIGHT_GREEN_API="${bright_green}api${reset}"
  local BRIGHT_BLUE_APP="${bright_blue}app${reset}"
  local ORANGE_CHAT="${orange}chat${reset}"
  local YELLOW_SCHEDULER="${yellow}scheduler${reset}"

  # Use sed with proper escaping for backslashes
  sed \
    -e 's/ichrisbirch-//g' \
    -e 's/-dev//g' \
    -e 's/-test//g' \
    -e 's/^api[ ]*|/'"${BRIGHT_GREEN_API}"' |/' \
    -e 's/^app[ ]*|/'"${BRIGHT_BLUE_APP}"' |/' \
    -e 's/^redis[ ]*|/'"${RED_REDIS}"' |/' \
    -e 's/^postgres[ ]*|/'"${GREEN_POSTGRES}"' |/' \
    -e 's/^nginx[ ]*|/'"${CYAN_NGINX}"' |/' \
    -e 's/^chat[ ]*|/'"${ORANGE_CHAT}"' |/' \
    -e 's/^scheduler[ ]*|/'"${YELLOW_SCHEDULER}"' |/' \
    -e 's/\[ERROR\]/'"${RED_ERROR}"'/g' \
    -e 's/\[WARNING\]/'"${YELLOW_WARNING}"'/g' \
    -e 's/\[DEBUG\]/'"${GREEN_DEBUG}"'/g' \
    -e 's/\[INFO\]/'"${BLUE_INFO}"'/g' \
    -e 's/\[CRITICAL\]/'"${MAGENTA_CRITICAL}"'/g'
}

function colored-status() {
  local GREEN_RUNNING="${green}running${reset}"
  local RED_EXITED="${red}exited${reset}"
  local YELLOW_RESTARTING="${yellow}restarting${reset}"
  local BLUE_PAUSED="${blue}paused${reset}"
  local MAGENTA_DEAD="${magenta}dead${reset}"
  local CYAN_CREATED="${cyan}created${reset}"
  local YELLOW_UNHEALTHY="${yellow}unhealthy${reset}"
  local GREEN_HEALTHY="${green}healthy${reset}"

  awk -v running="$GREEN_RUNNING" \
    -v exited="$RED_EXITED" \
    -v restarting="$YELLOW_RESTARTING" \
    -v paused="$BLUE_PAUSED" \
    -v dead="$MAGENTA_DEAD" \
    -v created="$CYAN_CREATED" \
    -v unhealthy="$YELLOW_UNHEALTHY" \
    -v healthy="$GREEN_HEALTHY" '
    {
        # Strip ichrisbirch- prefix from service names
        gsub(/ichrisbirch-/, "");
        # Color container states using gsub for all matches
        gsub(/running/, running);
        gsub(/exited/, exited);
        gsub(/restarting/, restarting);
        gsub(/paused/, paused);
        gsub(/dead/, dead);
        gsub(/created/, created);
        gsub(/unhealthy/, unhealthy);
        gsub(/healthy/, healthy);
        print $0;
    }'
}

function logs() {
  cd "$LOG_DIR" || exit
  ls -lH
  exec $SHELL
}

function install() {
  sudo ln -sf "$ICHRISBIRCH_HOME/cli/ichrisbirch" /usr/local/bin/ichrisbirch
}

function open() {
  cd "$ICHRISBIRCH_HOME" || exit
  echo "Opening ${green}ichrisbirch${reset} project in VS Code"
  code .
  echo "Starting tmux session"
  exec tmux new-session -d -s ichrisbirch || tmux attach-session -t ichrisbirch
}

function project-cd() {
  cd "$ICHRISBIRCH_HOME" || exit
  if [ -d ".venv" ]; then
    echo "Activating virtual environment"
    # shellcheck source=/dev/null
    source .venv/bin/activate
  fi
  exec "$SHELL"
}

# ============================================================================
# SSL CERTIFICATE MANAGEMENT
# ============================================================================

function ssl-manager() {
  local action="${1:-info}"
  local environment="${2:-all}"

  cd "$ICHRISBIRCH_HOME" || exit

  if [ -x "./deploy-containers/traefik/scripts/ssl-manager.sh" ]; then
    ./deploy-containers/traefik/scripts/ssl-manager.sh "$action" "$environment"
  else
    echo "${red}SSL manager script not found${reset}"
    echo "Expected: ${cyan}./deploy-containers/traefik/scripts/ssl-manager.sh${reset}"
    return 1
  fi
}

function dev-start() {
  cd "$ICHRISBIRCH_HOME" || exit

  # Ensure proxy network exists for Traefik
  if ! docker network inspect proxy >/dev/null 2>&1; then
    echo "Creating external proxy network..."
    docker network create proxy
  fi

  echo "Starting ${blue}DEV${reset} environment with ${green}Docker Compose + Traefik (HTTPS)${reset}"
  docker compose --project-name ichrisbirch-dev -f docker-compose.yml -f docker-compose.dev.yml up -d

  echo ""
  echo "Development environment started with ${green}HTTPS${reset}:"
  echo "  ${green}API${reset}:       ${cyan}https://api.docker.localhost/${reset}"
  echo "  ${green}APP${reset}:       ${cyan}https://app.docker.localhost/${reset}"
  echo "  ${green}CHAT${reset}:      ${cyan}https://chat.docker.localhost/${reset}"
  echo "  ${green}DASHBOARD${reset}: ${cyan}https://dashboard.docker.localhost/${reset} (user: dev, pass: devpass)"
  echo ""
  echo "Legacy HTTP access also available:"
  echo "  ${green}APP${reset}: ${cyan}http://localhost:5000${reset}"
  echo "  ${green}API${reset}: ${cyan}http://localhost:8000${reset}"
  echo "  ${green}CHAT${reset}: ${cyan}http://localhost:8505${reset}"
  echo "  ${green}PostgreSQL${reset}: ${cyan}localhost:5432${reset}"
  echo "  ${green}Redis${reset}: ${cyan}localhost:6379${reset}"
  echo ""
  echo "Use ${blue}ichrisbirch dev logs${reset} to view live container logs"
  echo "Use ${blue}ichrisbirch dev status${reset} to check service status"
  echo "Use ${blue}ichrisbirch dev health${reset} to run health checks"
}

function dev-stop() {
  cd "$ICHRISBIRCH_HOME" || exit
  echo "Stopping ${blue}DEV${reset} environment"
  docker compose --project-name ichrisbirch-dev -f docker-compose.yml -f docker-compose.dev.yml down
}

function dev-restart() {
  cd "$ICHRISBIRCH_HOME" || exit
  echo "Restarting ${blue}DEV${reset} environment"
  # Use 'up -d' instead of 'restart' to pick up any configuration changes
  docker compose --project-name ichrisbirch-dev -f docker-compose.yml -f docker-compose.dev.yml up -d
}

function dev-rebuild() {
  cd "$ICHRISBIRCH_HOME" || exit
  echo "Rebuilding and restarting ${blue}DEV${reset} environment"
  docker compose --project-name ichrisbirch-dev -f docker-compose.yml -f docker-compose.dev.yml down
  docker compose --project-name ichrisbirch-dev -f docker-compose.yml -f docker-compose.dev.yml up -d --build
}

function dev-logs() {
  cd "$ICHRISBIRCH_HOME" || exit
  echo "Viewing ${blue}DEV${reset} Docker container logs..."
  echo "Note: Application logs are in ${cyan}$LOG_DIR/{app,api,scheduler,chat}.log${reset}"

  # Show live Docker Compose logs with color formatting and clean service names
  docker compose --project-name ichrisbirch-dev -f docker-compose.yml -f docker-compose.dev.yml logs --follow --tail=50 | colored-logs
}

function dev-status() {
  cd "$ICHRISBIRCH_HOME" || exit
  echo "${blue}DEV${reset} environment status:"
  echo ""

  # Show container status with colors
  docker compose --project-name ichrisbirch-dev -f docker-compose.yml -f docker-compose.dev.yml ps --format "table {{.Service}}\t{{.State}}\t{{.Ports}}" | colored-status

  echo ""
  echo "${blue}Development${reset} URLs:"
  echo "  • API:       https://api.docker.localhost/"
  echo "  • App:       https://app.docker.localhost/"
  echo "  • Chat:      https://chat.docker.localhost/"
  echo "  • Dashboard: https://dashboard.docker.localhost/ (user: dev, pass: devpass)"
}

function dev-monitor() {
  tmuxinator ichrisbirch-dev-monitoring
}

function dev-health() {
  echo "Running health check for ${blue}DEV${reset} environment"

  cd "$ICHRISBIRCH_HOME" || exit

  if [ -x "./deploy-containers/traefik/scripts/health-check.sh" ]; then
    ./deploy-containers/traefik/scripts/health-check.sh dev
  else
    echo "${red}Health check script not found${reset}"
    echo "Expected: ${cyan}./deploy-containers/traefik/scripts/health-check.sh${reset}"
    return 1
  fi
}

function test-run() {
  cd "$ICHRISBIRCH_HOME" || exit
  mkdir -p "$ICHRISBIRCH_HOME/test-logs"
  # shellcheck disable=1091
  source "$ICHRISBIRCH_HOME/.venv/bin/activate"
  export ENVIRONMENT=testing

  # If no arguments, run all tests
  # Otherwise, pass all arguments to pytest
  if [ $# -eq 0 ]; then
    uv run pytest
  else
    uv run pytest "$@"
  fi
}

function test-cov() {
  cd "$ICHRISBIRCH_HOME" || exit
  mkdir -p "$ICHRISBIRCH_HOME/test-logs"
  # shellcheck disable=1091
  source "$ICHRISBIRCH_HOME/.venv/bin/activate"
  export ENVIRONMENT=testing

  # Run pytest with coverage
  if [ $# -eq 0 ]; then
    uv run pytest --cov=ichrisbirch --cov-report=html
  else
    uv run pytest --cov=ichrisbirch --cov-report=html "$@"
  fi
  echo ""
  echo "Coverage report: ${cyan}file://$ICHRISBIRCH_HOME/htmlcov/index.html${reset}"
}

function testing-start() {
  cd "$ICHRISBIRCH_HOME" || exit

  # Create test-logs directory if it doesn't exist
  mkdir -p "$ICHRISBIRCH_HOME/test-logs"

  # Ensure proxy network exists for Traefik
  if ! docker network inspect proxy >/dev/null 2>&1; then
    echo "Creating external proxy network..."
    docker network create proxy
  fi

  echo "Starting ${blue}TESTING${reset} environment with ${green}Docker Compose + Traefik (HTTPS)${reset}"
  docker compose --project-name ichrisbirch-test -f docker-compose.yml -f docker-compose.test.yml up -d

  echo "Waiting for services to be ready..."
  sleep 15

  echo "Initializing test database..."
  # Use virtual environment and run database initialization
  # shellcheck disable=1091
  source "$ICHRISBIRCH_HOME/.venv/bin/activate"

  # Run test database initialization from host (need to use localhost, not Docker hostname)
  if ENVIRONMENT=testing uv run python -m ichrisbirch.database.initialization --env testing --db-host localhost --db-port 5434; then
    echo "${green}Database initialized successfully${reset}"
  else
    echo "${red}Database initialization failed${reset}"
    echo "Check logs for details. You may need to run:"
    echo "   ${blue}ichrisbirch testing stop${reset}"
    echo "   ${blue}ichrisbirch testing start${reset}"
    return 1
  fi

  echo ""
  echo "Testing environment started with ${green}HTTPS${reset}:"
  echo "  ${green}API${reset}:       ${cyan}https://api.test.localhost:8443/${reset}"
  echo "  ${green}APP${reset}:       ${cyan}https://app.test.localhost:8443/${reset}"
  echo "  ${green}CHAT${reset}:      ${cyan}https://chat.test.localhost:8443/${reset}"
  echo "  ${green}DASHBOARD${reset}: ${cyan}https://dashboard.test.localhost:8443/${reset} (user: test, pass: testpass)"
  echo ""
  echo "Legacy HTTP access also available:"
  echo "  ${green}APP${reset}: ${cyan}http://localhost:5001${reset}"
  echo "  ${green}API${reset}: ${cyan}http://localhost:8001${reset}"
  echo "  ${green}CHAT${reset}: ${cyan}http://localhost:8507${reset}"
  echo "  ${green}PostgreSQL${reset}: ${cyan}localhost:5434${reset}"
  echo "  ${green}Redis${reset}: ${cyan}localhost:6380${reset}"
  echo ""
  echo "Test logs available at: ${cyan}$ICHRISBIRCH_HOME/test-logs/${reset}"
  echo "Use ${blue}ichrisbirch testing app-logs${reset} to view application logs"
  echo "Use ${blue}ichrisbirch testing logs${reset} to view Docker container logs"
  echo "Use ${blue}ichrisbirch testing health${reset} to run health checks"
}

function testing-stop() {
  cd "$ICHRISBIRCH_HOME" || exit
  echo "Stopping ${blue}TESTING${reset} environment"
  docker compose --project-name ichrisbirch-test -f docker-compose.yml -f docker-compose.test.yml down
}

function testing-restart() {
  cd "$ICHRISBIRCH_HOME" || exit
  echo "Restarting ${blue}TESTING${reset} environment"
  # Use 'up -d' instead of 'restart' to pick up any configuration changes
  docker compose --project-name ichrisbirch-test -f docker-compose.yml -f docker-compose.test.yml up -d
}

function testing-rebuild() {
  cd "$ICHRISBIRCH_HOME" || exit
  echo "Rebuilding and restarting ${blue}TESTING${reset} environment"
  docker compose --project-name ichrisbirch-test -f docker-compose.yml -f docker-compose.test.yml down
  docker compose --project-name ichrisbirch-test -f docker-compose.yml -f docker-compose.test.yml up -d --build
}

function testing-logs() {
  cd "$ICHRISBIRCH_HOME" || exit
  echo "Viewing ${blue}TESTING${reset} Docker container logs..."
  echo "Note: Application logs are in ${cyan}$LOG_DIR/{app,api,scheduler,chat}.log${reset}"

  # Show live Docker Compose logs with color formatting and clean service names
  docker compose --project-name ichrisbirch-test -f docker-compose.yml -f docker-compose.test.yml logs --follow --tail=50 | colored-logs
}

function testing-app-logs() {
  local lines="${1:-100}"
  local follow_flag=""

  # Check if --follow is passed as first or second argument
  if [[ "$1" == "--follow" ]] || [[ "$2" == "--follow" ]]; then
    follow_flag="--follow"
    # Adjust lines if --follow was passed as first argument
    if [[ "$1" == "--follow" ]]; then
      lines="${2:-100}"
    fi
  fi

  cd "$ICHRISBIRCH_HOME" || exit
  local test_logs_dir="$ICHRISBIRCH_HOME/test-logs"
  local log_file="$test_logs_dir/testing.log"

  # Check if test logs directory exists
  if [[ ! -d "$test_logs_dir" ]]; then
    echo "${red}Test logs directory not found: $test_logs_dir${reset}"
    echo "${cyan}Make sure the test environment has been started at least once:${reset}"
    echo "   ${blue}ichrisbirch testing start${reset}"
    return 1
  fi

  # Check if consolidated log file exists
  if [[ ! -f "$log_file" ]]; then
    echo "${red}Test log file not found: $log_file${reset}"
    echo "${cyan}Make sure the test environment is running to generate logs:${reset}"
    echo "   ${blue}ichrisbirch testing start${reset}"
    return 1
  fi

  echo "Viewing ${blue}TESTING${reset} application logs from: ${cyan}$log_file${reset}"

  if [[ -n "$follow_flag" ]]; then
    echo "   Mode: ${green}Follow${reset} (press Ctrl+C to exit)"
    echo ""
    tail -f "$log_file" | colored-logs
  else
    echo "   Lines: $lines"
    echo ""
    tail -n "$lines" "$log_file" | colored-logs
  fi
}

function testing-app-logs-follow() {
  testing-app-logs --follow
}

function testing-status() {
  cd "$ICHRISBIRCH_HOME" || exit
  echo "${blue}TESTING${reset} environment status:"
  echo ""

  # Show container status with colors
  docker compose --project-name ichrisbirch-test -f docker-compose.yml -f docker-compose.test.yml ps --format "table {{.Service}}\t{{.State}}\t{{.Ports}}" | colored-status

  echo ""
  echo "${blue}Test${reset} URLs:"
  echo "  • API:       https://api.test.localhost:8443/"
  echo "  • App:       https://app.test.localhost:8443/"
  echo "  • Chat:      https://chat.test.localhost:8443/"
  echo "  • Dashboard: https://dashboard.test.localhost:8443/ (user: test, pass: testpass)"
}

function testing-health() {
  echo "Running health check for ${blue}TESTING${reset} environment"

  cd "$ICHRISBIRCH_HOME" || exit

  if [ -x "./deploy-containers/traefik/scripts/health-check.sh" ]; then
    ./deploy-containers/traefik/scripts/health-check.sh test
  else
    echo "${red}Health check script not found${reset}"
    echo "Expected: ${cyan}./deploy-containers/traefik/scripts/health-check.sh${reset}"
    return 1
  fi
}

# Helper to load production environment variables from AWS SSM
function load-prod-env() {
  local aws_region="${AWS_REGION:-us-east-2}"
  local environment="production"

  get_ssm_param() {
    aws ssm get-parameter \
      --region "$aws_region" \
      --name "/ichrisbirch/$environment/$1" \
      --with-decryption \
      --query 'Parameter.Value' \
      --output text
  }

  export POSTGRES_PASSWORD
  POSTGRES_PASSWORD=$(get_ssm_param "postgres/password") || {
    echo "${red}Failed to fetch POSTGRES_PASSWORD from SSM${reset}"
    return 1
  }

  export REDIS_PASSWORD
  REDIS_PASSWORD=$(get_ssm_param "redis/password") || {
    echo "${red}Failed to fetch REDIS_PASSWORD from SSM${reset}"
    return 1
  }

  export DOMAIN="${DOMAIN:-ichrisbirch.com}"
}

function prod-start() {
  cd "$ICHRISBIRCH_HOME" || exit

  echo "Fetching secrets from AWS SSM..."
  load-prod-env || return 1
  echo "Secrets loaded for ${magenta}production${reset}"

  # Ensure proxy network exists for Traefik
  if ! docker network inspect proxy >/dev/null 2>&1; then
    echo "Creating external proxy network..."
    docker network create proxy
  fi

  echo "Starting ${magenta}PRODUCTION${reset} environment with ${green}Docker Compose + Traefik${reset}"
  echo "  (Cloudflare Tunnel handles external HTTPS)"
  docker compose --project-name ichrisbirch-prod -f docker-compose.yml up -d

  echo ""
  echo "Production environment started:"
  echo "  ${green}APP${reset}:  ${cyan}https://${DOMAIN}/${reset}"
  echo "  ${green}API${reset}:  ${cyan}https://api.${DOMAIN}/${reset}"
  echo "  ${green}CHAT${reset}: ${cyan}https://chat.${DOMAIN}/${reset}"
  echo ""
  echo "Use ${blue}ichrisbirch prod logs${reset} to view live container logs"
  echo "Use ${blue}ichrisbirch prod status${reset} to check service status"
  echo "Use ${blue}ichrisbirch prod health${reset} to run health checks"
}

function prod-stop() {
  cd "$ICHRISBIRCH_HOME" || exit
  load-prod-env || return 1
  echo "Stopping ${magenta}PRODUCTION${reset} environment"
  docker compose --project-name ichrisbirch-prod -f docker-compose.yml down
}

function prod-restart() {
  cd "$ICHRISBIRCH_HOME" || exit
  load-prod-env || return 1
  echo "Restarting ${magenta}PRODUCTION${reset} environment"
  # Use 'up -d' instead of 'restart' to pick up any configuration changes
  docker compose --project-name ichrisbirch-prod -f docker-compose.yml up -d
}

function prod-rebuild() {
  cd "$ICHRISBIRCH_HOME" || exit

  echo "Fetching secrets from AWS SSM..."
  load-prod-env || return 1

  echo "Rebuilding and restarting ${magenta}PRODUCTION${reset} environment"
  docker compose --project-name ichrisbirch-prod -f docker-compose.yml down
  docker compose --project-name ichrisbirch-prod -f docker-compose.yml up -d --build
}

function prod-monitor() {
  tmuxinator ichrisbirch-prod-monitoring
}

function prod-logs() {
  cd "$ICHRISBIRCH_HOME" || exit
  load-prod-env || return 1

  echo "Viewing ${magenta}PRODUCTION${reset} Docker container logs..."
  docker compose --project-name ichrisbirch-prod -f docker-compose.yml logs --follow --tail=50 | colored-logs
}

function prod-status() {
  cd "$ICHRISBIRCH_HOME" || exit
  load-prod-env || return 1

  echo "${magenta}PRODUCTION${reset} environment status:"
  echo ""
  docker compose --project-name ichrisbirch-prod -f docker-compose.yml ps --format "table {{.Service}}\t{{.State}}\t{{.Ports}}" | colored-status

  echo ""
  echo "${magenta}Production${reset} URLs (via Cloudflare Tunnel):"
  echo "  • App:  https://${DOMAIN}/"
  echo "  • API:  https://api.${DOMAIN}/"
  echo "  • Chat: https://chat.${DOMAIN}/"
}

function prod-health() {
  echo "Running health check for ${magenta}PRODUCTION${reset} environment"

  cd "$ICHRISBIRCH_HOME" || exit

  if [ -x "./deploy-containers/traefik/scripts/health-check.sh" ]; then
    ./deploy-containers/traefik/scripts/health-check.sh prod
  else
    echo "${red}Health check script not found${reset}"
    echo "Expected: ${cyan}./deploy-containers/traefik/scripts/health-check.sh${reset}"
    return 1
  fi
}

function prod-apihealth() {
  curl --silent https://api.ichrisbirch.com/health/ | jq
}

# ============================================================================
# PROJECT STATS (Event-Sourced)
# ============================================================================

function stats-latest-file() {
  find "$ICHRISBIRCH_HOME/stats" -maxdepth 1 -name 'stats_*.json' -type f -printf '%T@ %p\n' 2>/dev/null | sort -rn | head -1 | cut -d' ' -f2-
}

function stats-show() {
  cd "$ICHRISBIRCH_HOME" || exit
  local stats_file
  stats_file=$(stats-latest-file)
  local events_file="$ICHRISBIRCH_HOME/stats/events/events.jsonl"

  echo "${green}Project Stats Summary${reset}"
  echo ""

  if [ -z "$stats_file" ] || [ ! -f "$stats_file" ]; then
    echo "${yellow}No stats snapshots found.${reset}"
    echo "Stats are collected automatically on each commit."
    return
  fi

  local collected_at
  collected_at=$(jq -r '.collected_at' "$stats_file" | cut -d'T' -f1)
  echo "Last collected: ${cyan}$collected_at${reset}"
  echo ""

  # Code stats (live from tokei) - show top 5 languages
  # Use max(code, comments) to handle prose languages (Markdown counts content as comments)
  local tokei_json total_loc
  tokei_json=$(tokei . --compact --output json 2>/dev/null)
  total_loc=$(echo "$tokei_json" | jq -r '[.[] | select(.code != null)] | map([.code, .comments] | max) | add // 0')

  echo "${blue}Code${reset}"
  echo "$tokei_json" | jq -r 'to_entries | map(select(.value.code != null and .key != "Total")) | sort_by(-([.value.code, .value.comments] | max)) | .[0:5] | .[] | "\(.key)\t\([.value.code, .value.comments] | max)\t\(.value.reports | length)"' | \
    while IFS=$'\t' read -r lang content files; do
      printf "  %-10s %'6d lines (%d files)\n" "$lang:" "$content" "$files"
    done
  printf "  ${cyan}%-10s %'6d lines${reset}\n" "Total:" "$total_loc"
  echo ""

  # Tests
  local tests_total tests_passed tests_failed coverage duration
  tests_total=$(jq -r '.tests.total // 0' "$stats_file")
  tests_passed=$(jq -r '.tests.passed // 0' "$stats_file")
  tests_failed=$(jq -r '.tests.failed // 0' "$stats_file")
  coverage=$(jq -r '.coverage.line_percent // 0' "$stats_file")
  duration=$(jq -r '.tests.duration_seconds // 0' "$stats_file" | cut -d'.' -f1)

  local pass_rate=0
  if [ "$tests_total" -gt 0 ]; then
    pass_rate=$((tests_passed * 100 / tests_total))
  fi

  echo "${blue}Tests${reset}"
  if [ "$tests_failed" -eq 0 ]; then
    printf "  Total:       %d tests (${green}%d%% pass${reset})\n" "$tests_total" "$pass_rate"
  else
    printf "  Total:       %d tests (${red}%d failed${reset})\n" "$tests_total" "$tests_failed"
  fi
  printf "  Coverage:    ${cyan}%.1f%%${reset}\n" "$coverage"
  printf "  Duration:    %ds\n" "$duration"
  echo ""

  # Dependencies
  local deps_direct deps_total
  deps_direct=$(jq -r '.dependencies.direct // 0' "$stats_file")
  deps_total=$(jq -r '.dependencies.total // 0' "$stats_file")

  echo "${blue}Dependencies${reset}"
  printf "  Direct:      %d packages\n" "$deps_direct"
  printf "  Total:       %d packages\n" "$deps_total"
  echo ""

  # Commit activity
  if [ -f "$events_file" ]; then
    local total_commits today_commits week_commits
    total_commits=$(grep -c '"type":"commit"' "$events_file" 2>/dev/null || echo 0)
    today_commits=$(grep '"type":"commit"' "$events_file" | grep -c "$(date +%Y-%m-%d)")

    local week_pattern
    week_pattern=$(for i in $(seq 0 6); do date -d "-${i} days" +%Y-%m-%d; done | paste -sd'|')
    week_commits=$(grep '"type":"commit"' "$events_file" | grep -cE "$week_pattern")

    echo "${blue}Activity${reset}"
    printf "  Today:       %d commits\n" "$today_commits"
    printf "  This week:   %d commits\n" "$week_commits"
    printf "  All time:    %d commits\n" "$total_commits"
  fi
}

function stats-code() {
  cd "$ICHRISBIRCH_HOME" || exit

  echo "${green}Code Statistics by Language${reset}"
  echo ""

  printf "${cyan}%-15s %10s %10s %8s${reset}\n" "Language" "Content" "Blanks" "Files"
  echo "---------------------------------------------------"

  # Run tokei directly for real-time stats
  # For code: content = code, for prose (Markdown): content = comments
  # We use max(code, comments) as content to handle both properly
  local tokei_json
  tokei_json=$(tokei . --compact --output json 2>/dev/null)

  echo "$tokei_json" | \
    jq -r 'to_entries | map(select(.value.code != null and .key != "Total")) | sort_by(-([.value.code, .value.comments] | max)) | .[] | [.key, ([.value.code, .value.comments] | max), .value.blanks, (.value.reports | length)] | @tsv' | \
    while IFS=$'\t' read -r lang content blanks files; do
      printf "%-15s %'10d %'10d %8d\n" "$lang" "$content" "$blanks" "$files"
    done

  echo "---------------------------------------------------"
  local total_content total_blanks
  total_content=$(echo "$tokei_json" | jq -r '[.[] | select(.code != null)] | map([.code, .comments] | max) | add')
  total_blanks=$(echo "$tokei_json" | jq -r '[.[] | select(.code != null)] | map(.blanks) | add')
  printf "${green}%-15s %'10d %'10d${reset}\n" "Total" "$total_content" "$total_blanks"
}

function stats-tests() {
  cd "$ICHRISBIRCH_HOME" || exit
  local stats_file
  stats_file=$(stats-latest-file)

  echo "${green}Test Statistics${reset}"
  echo ""

  if [ -z "$stats_file" ] || [ ! -f "$stats_file" ]; then
    echo "${yellow}No stats snapshots found.${reset}"
    return
  fi

  local total passed failed skipped errors duration coverage
  total=$(jq -r '.tests.total // 0' "$stats_file")
  passed=$(jq -r '.tests.passed // 0' "$stats_file")
  failed=$(jq -r '.tests.failed // 0' "$stats_file")
  skipped=$(jq -r '.tests.skipped // 0' "$stats_file")
  errors=$(jq -r '.tests.errors // 0' "$stats_file")
  duration=$(jq -r '.tests.duration_seconds // 0' "$stats_file")
  coverage=$(jq -r '.coverage.line_percent // 0' "$stats_file")

  echo "${blue}Results${reset}"
  printf "  Total:     %d\n" "$total"
  printf "  Passed:    ${green}%d${reset}\n" "$passed"
  [ "$failed" -gt 0 ] && printf "  Failed:    ${red}%d${reset}\n" "$failed"
  [ "$skipped" -gt 0 ] && printf "  Skipped:   ${yellow}%d${reset}\n" "$skipped"
  [ "$errors" -gt 0 ] && printf "  Errors:    ${red}%d${reset}\n" "$errors"
  echo ""

  echo "${blue}Performance${reset}"
  printf "  Duration:  %.1fs\n" "$duration"
  printf "  Coverage:  %.1f%%\n" "$coverage"
  echo ""

  echo "${blue}Slowest Tests${reset}"
  jq -r '.tests.slowest[:5] | .[] | "  " + (.duration | tostring | .[0:5]) + "s  " + .name' "$stats_file" | \
    sed 's|tests/ichrisbirch/||g' | sed 's|::test_|: |g'
}

function stats-quality() {
  cd "$ICHRISBIRCH_HOME" || exit
  local events_file="$ICHRISBIRCH_HOME/stats/events/events.jsonl"

  echo "${green}Code Quality - Issues Caught${reset}"
  echo ""

  if [ ! -f "$events_file" ]; then
    echo "${yellow}No events file found.${reset}"
    return
  fi

  # Date patterns for filtering
  local today day7 day30
  today=$(date +%Y-%m-%d)
  day7=$(date -d "-7 days" +%Y-%m-%d)
  day30=$(date -d "-30 days" +%Y-%m-%d)

  printf "${cyan}%-12s %6s %6s %6s %6s${reset}\n" "Tool" "24h" "7d" "30d" "All"
  echo "----------------------------------------------"

  local tools=("ruff" "mypy" "bandit" "shellcheck" "codespell" "detect-private-key")

  for tool in "${tools[@]}"; do
    local issues_today issues_7d issues_30d issues_all

    # Count issues for each time period
    issues_today=$(grep "\"type\":\"hook.$tool\"" "$events_file" | grep "$today" | jq -s '[.[].issues | length] | add // 0')
    issues_7d=$(grep "\"type\":\"hook.$tool\"" "$events_file" | grep -E "$(for i in $(seq 0 6); do date -d "-${i} days" +%Y-%m-%d; done | paste -sd'|')" | jq -s '[.[].issues | length] | add // 0')
    issues_30d=$(grep "\"type\":\"hook.$tool\"" "$events_file" | grep -E "$(for i in $(seq 0 29); do date -d "-${i} days" +%Y-%m-%d; done | paste -sd'|')" | jq -s '[.[].issues | length] | add // 0')
    issues_all=$(grep "\"type\":\"hook.$tool\"" "$events_file" | jq -s '[.[].issues | length] | add // 0')

    # Format with colors - use fixed width padding after color codes
    local c_today c_7d c_30d c_all
    if [ "$issues_today" -eq 0 ]; then
      c_today="${gray}     0${reset}"
    else
      c_today="${yellow}$(printf '%6d' "$issues_today")${reset}"
    fi
    if [ "$issues_7d" -eq 0 ]; then
      c_7d="${gray}     0${reset}"
    else
      c_7d="${yellow}$(printf '%6d' "$issues_7d")${reset}"
    fi
    if [ "$issues_30d" -eq 0 ]; then
      c_30d="${gray}     0${reset}"
    else
      c_30d="${yellow}$(printf '%6d' "$issues_30d")${reset}"
    fi
    if [ "$issues_all" -eq 0 ]; then
      c_all="${gray}     0${reset}"
    else
      c_all="$(printf '%6d' "$issues_all")"
    fi

    printf "%-12s %s %s %s %s\n" "$tool" "$c_today" "$c_7d" "$c_30d" "$c_all"
  done

  echo ""

  # Show hook run counts
  local runs_today runs_7d
  runs_today=$(grep '"type":"hook\.' "$events_file" | grep -c "$today")
  runs_7d=$(grep '"type":"hook\.' "$events_file" | grep -cE "$(for i in $(seq 0 6); do date -d "-${i} days" +%Y-%m-%d; done | paste -sd'|')")

  echo "${blue}Hook Runs${reset}"
  printf "  Today:     %d runs\n" "$runs_today"
  printf "  Last 7d:   %d runs\n" "$runs_7d"
}

function stats-activity() {
  cd "$ICHRISBIRCH_HOME" || exit
  local days="${1:-7}"
  local events_file="$ICHRISBIRCH_HOME/stats/events/events.jsonl"

  echo "${green}Commit Activity (last $days days)${reset}"
  echo ""

  if [ ! -f "$events_file" ]; then
    echo "${yellow}No events file found.${reset}"
    return
  fi

  for i in $(seq 0 $((days - 1))); do
    local date_str day_name
    date_str=$(date -d "-${i} days" +%Y-%m-%d)
    day_name=$(date -d "-${i} days" +%a)

    local count
    count=$(grep '"type":"commit"' "$events_file" | grep -c "$date_str")

    local bar=""
    for ((j = 0; j < count && j < 20; j++)); do
      bar="${bar}#"
    done
    [ "$count" -gt 20 ] && bar="${bar}+"

    if [ "$i" -eq 0 ]; then
      printf "${cyan}%-10s${reset} %-3s  ${green}%-20s${reset} %d\n" "$date_str" "$day_name" "$bar" "$count"
    else
      printf "%-10s %-3s  ${green}%-20s${reset} %d\n" "$date_str" "$day_name" "$bar" "$count"
    fi
  done

  echo ""
  local total_week
  total_week=$(grep -c '"type":"commit"' "$events_file")
  echo "Total recorded commits: $total_week"
}

function stats-events() {
  cd "$ICHRISBIRCH_HOME" || exit
  local count="${1:-20}"
  local events_file="$ICHRISBIRCH_HOME/stats/events/events.jsonl"

  echo "${green}Recent Events (last $count)${reset}"
  echo ""

  if [ -f "$events_file" ]; then
    tail -n "$count" "$events_file" | jq -r '[.type, .timestamp[11:19], (.status // "-")] | @tsv' | column -t
  else
    echo "${yellow}No events file found.${reset}"
  fi
}

function stats-trends() {
  cd "$ICHRISBIRCH_HOME" || exit

  echo "${green}Project Trends${reset}"
  echo ""

  # Helper to format percent change with color
  format_change() {
    local current=$1 previous=$2 label=$3 invert=${4:-false}
    if [ "$previous" -eq 0 ] || [ "$current" -eq 0 ]; then
      printf "  %-14s %s\n" "$label:" "${gray}--${reset}"
      return
    fi
    local change=$(( (current - previous) * 100 / previous ))
    local arrow color
    if [ "$change" -gt 0 ]; then
      arrow="↑"
      [ "$invert" = "true" ] && color="$red" || color="$green"
    elif [ "$change" -lt 0 ]; then
      arrow="↓"
      [ "$invert" = "true" ] && color="$green" || color="$red"
      change=$((-change))
    else
      arrow="→"
      color="$gray"
    fi
    printf "  %-14s ${color}%s%d%%${reset} (%d → %d)\n" "$label:" "$arrow" "$change" "$previous" "$current"
  }

  # Get commit counts for different periods
  echo "${blue}Commit Velocity${reset}"
  local today_commits week_commits month_commits prev_week prev_month
  today_commits=$(git log --oneline --since="24 hours ago" 2>/dev/null | wc -l | tr -d ' ')
  week_commits=$(git log --oneline --since="7 days ago" 2>/dev/null | wc -l | tr -d ' ')
  month_commits=$(git log --oneline --since="30 days ago" 2>/dev/null | wc -l | tr -d ' ')
  prev_week=$(git log --oneline --since="14 days ago" --until="7 days ago" 2>/dev/null | wc -l | tr -d ' ')
  prev_month=$(git log --oneline --since="60 days ago" --until="30 days ago" 2>/dev/null | wc -l | tr -d ' ')

  printf "  %-14s %d\n" "Today:" "$today_commits"
  format_change "$week_commits" "$prev_week" "7d vs prev 7d"
  format_change "$month_commits" "$prev_month" "30d vs prev 30d"
  echo ""

  # Code changes from git
  echo "${blue}Code Churn (lines changed)${reset}"
  local week_added week_deleted month_added month_deleted
  week_added=$(git log --since="7 days ago" --numstat --pretty="" 2>/dev/null | awk '{s+=$1} END {print s+0}')
  week_deleted=$(git log --since="7 days ago" --numstat --pretty="" 2>/dev/null | awk '{s+=$2} END {print s+0}')
  month_added=$(git log --since="30 days ago" --numstat --pretty="" 2>/dev/null | awk '{s+=$1} END {print s+0}')
  month_deleted=$(git log --since="30 days ago" --numstat --pretty="" 2>/dev/null | awk '{s+=$2} END {print s+0}')

  printf "  %-14s ${green}+%'d${reset} / ${red}-%'d${reset}\n" "Last 7 days:" "$week_added" "$week_deleted"
  printf "  %-14s ${green}+%'d${reset} / ${red}-%'d${reset}\n" "Last 30 days:" "$month_added" "$month_deleted"
  echo ""

  # Test and coverage trends from stats snapshots
  echo "${blue}Test Suite${reset}"
  local stats_dir="$ICHRISBIRCH_HOME/stats"
  local latest_stats oldest_stats
  latest_stats=$(find "$stats_dir" -maxdepth 1 -name 'stats_*.json' -type f -printf '%T@ %p\n' 2>/dev/null | sort -rn | head -1 | cut -d' ' -f2-)
  oldest_stats=$(find "$stats_dir" -maxdepth 1 -name 'stats_*.json' -type f -printf '%T@ %p\n' 2>/dev/null | sort -n | head -1 | cut -d' ' -f2-)

  if [ -n "$latest_stats" ] && [ -n "$oldest_stats" ]; then
    local curr_tests prev_tests curr_cov prev_cov curr_dur prev_dur
    curr_tests=$(jq -r '.tests.total // 0' "$latest_stats")
    prev_tests=$(jq -r '.tests.total // 0' "$oldest_stats")
    curr_cov=$(jq -r '.coverage.line_percent // 0' "$latest_stats" | cut -d'.' -f1)
    prev_cov=$(jq -r '.coverage.line_percent // 0' "$oldest_stats" | cut -d'.' -f1)
    curr_dur=$(jq -r '.tests.duration_seconds // 0' "$latest_stats" | cut -d'.' -f1)
    prev_dur=$(jq -r '.tests.duration_seconds // 0' "$oldest_stats" | cut -d'.' -f1)

    format_change "$curr_tests" "$prev_tests" "Test count"
    format_change "$curr_cov" "$prev_cov" "Coverage %"
    format_change "$curr_dur" "$prev_dur" "Duration (s)" true
  else
    printf "  %sNo historical snapshots for comparison%s\n" "$gray" "$reset"
  fi
  echo ""

  # Python LOC trend
  echo "${blue}Python LOC (from git)${reset}"
  local py_week_added py_week_deleted py_month_added py_month_deleted
  py_week_added=$(git log --since="7 days ago" --numstat --pretty="" -- '*.py' 2>/dev/null | awk '{s+=$1} END {print s+0}')
  py_week_deleted=$(git log --since="7 days ago" --numstat --pretty="" -- '*.py' 2>/dev/null | awk '{s+=$2} END {print s+0}')
  py_month_added=$(git log --since="30 days ago" --numstat --pretty="" -- '*.py' 2>/dev/null | awk '{s+=$1} END {print s+0}')
  py_month_deleted=$(git log --since="30 days ago" --numstat --pretty="" -- '*.py' 2>/dev/null | awk '{s+=$2} END {print s+0}')

  local py_week_net=$((py_week_added - py_week_deleted))
  local py_month_net=$((py_month_added - py_month_deleted))

  if [ "$py_week_net" -ge 0 ]; then
    printf "  %-14s ${green}+%'d${reset} net (${green}+%'d${reset}/${red}-%'d${reset})\n" "Last 7 days:" "$py_week_net" "$py_week_added" "$py_week_deleted"
  else
    printf "  %-14s ${red}%'d${reset} net (${green}+%'d${reset}/${red}-%'d${reset})\n" "Last 7 days:" "$py_week_net" "$py_week_added" "$py_week_deleted"
  fi
  if [ "$py_month_net" -ge 0 ]; then
    printf "  %-14s ${green}+%'d${reset} net (${green}+%'d${reset}/${red}-%'d${reset})\n" "Last 30 days:" "$py_month_net" "$py_month_added" "$py_month_deleted"
  else
    printf "  %-14s ${red}%'d${reset} net (${green}+%'d${reset}/${red}-%'d${reset})\n" "Last 30 days:" "$py_month_net" "$py_month_added" "$py_month_deleted"
  fi
  echo ""

  # Sparkline of activity
  echo "${blue}Activity Sparkline (30 days)${reset}"
  printf "  "
  local max_day=0
  declare -a day_counts
  for i in $(seq 29 -1 0); do
    local d
    d=$(date -d "-${i} days" +%Y-%m-%d)
    local cnt
    cnt=$(git log --oneline --since="$d 00:00:00" --until="$d 23:59:59" 2>/dev/null | wc -l | tr -d ' ')
    day_counts[i]=$cnt
    [ "$cnt" -gt "$max_day" ] && max_day=$cnt
  done
  local bars=("▁" "▂" "▃" "▄" "▅" "▆" "▇" "█")
  for i in $(seq 29 -1 0); do
    local cnt=${day_counts[i]}
    if [ "$max_day" -eq 0 ]; then
      printf "%s▁%s" "$gray" "$reset"
    elif [ "$cnt" -eq 0 ]; then
      printf "%s▁%s" "$gray" "$reset"
    else
      local idx=$(( (cnt * 7) / max_day ))
      printf "%s%s%s" "$green" "${bars[$idx]}" "$reset"
    fi
  done
  printf "\n  %s30d ago                        today%s\n" "$gray" "$reset"
}

function usage() {
  echo "${yellow}           _                  _                  _       ${reset}"
  echo "${yellow}  (*)     |=|         (*)    |=|   (*)          |=|      ${reset}"
  echo "${yellow}   _  ____|=| _   ____ _  ___|=| _  _  ____ ____|=| _    ${reset}"
  echo "${yellow}  |=|/ ___)=|| =\/ ___)=|/___)=|| \|=|/ ___) ___)=|| =\  ${reset}"
  echo "${yellow}  |=(=(___|=| |=|=|   |=|___ |=|_)=)=|=|  (=(___|=| |=|  ${reset}"
  echo "${yellow}  |_|\____)_| |_|_|   |_(___/|____/|_|_|   \____)_| |_|  ${reset}"
  echo
  echo "${green}Core Commands:${reset}"
  echo "  ${blue}open${reset}      - Launch VS Code and create tmux session for development"
  echo "  ${blue}cd${reset}        - Navigate to project directory and activate Python virtual environment"
  echo "  ${blue}logs${reset}      - List log files in configured log directory"
  echo "  ${blue}test run${reset}  - Execute pytest (supports paths and args, see below)"
  echo "  ${blue}ssl-manager <action> [env]${reset} - Manage SSL certificates for HTTPS"
  echo "    • ${yellow}Actions${reset}: generate, validate, info"
  echo "    • ${yellow}Environments${reset}: dev, test, prod, all"
  echo "    • ${yellow}Examples${reset}: ${cyan}ssl-manager generate dev${reset}, ${cyan}ssl-manager info all${reset}"
  echo
  echo "${green}Development Environment (HTTPS with Traefik):${reset}"
  echo "  ${blue}dev start${reset}     - Start development services with HTTPS (api.docker.localhost, app.docker.localhost, etc.)"
  echo "  ${blue}dev stop${reset}      - Stop all development services and remove containers"
  echo "  ${blue}dev restart${reset}   - Restart existing containers without rebuilding images (quick recovery from crashes)"
  echo "  ${blue}dev rebuild${reset}   - Stop services, rebuild Docker images, and restart (use after code/dependency changes)"
  echo "  ${blue}dev logs${reset}      - View live Docker container logs"
  echo "  ${blue}dev status${reset}    - Display container status and service URLs"
  echo "  ${blue}dev health${reset}    - Run comprehensive health checks for all services"
  echo
  echo "${green}Test Environment (HTTPS with Traefik - runs alongside dev):${reset}"
  echo "  ${blue}testing start${reset}   - Start isolated test services with HTTPS (api.test.localhost:8443, etc.)"
  echo "  ${blue}testing stop${reset}    - Stop test environment services"
  echo "  ${blue}testing restart${reset} - Restart test containers without rebuilding"
  echo "  ${blue}testing rebuild${reset} - Rebuild and restart test environment"
  echo "  ${blue}testing logs${reset}    - View live test container logs (Docker Compose output)"
  echo "  ${blue}testing status${reset}  - Display test container status and service URLs"
  echo "  ${blue}testing health${reset}  - Run comprehensive health checks for test services"
  echo "  ${blue}testing app-logs [lines] [--follow]${reset} - View consolidated application logs from testing.log"
  echo "    • ${yellow}lines${reset}: number of lines to show (default: 100)"
  echo "    • ${yellow}--follow${reset}: follow logs in real-time"
  echo "    • Examples: ${cyan}testing app-logs${reset}, ${cyan}testing app-logs 50${reset}, ${cyan}testing app-logs --follow${reset}"
  echo "  ${blue}testing app-logs-follow${reset} - Follow consolidated application logs in real-time"
  echo "  ${blue}test run [path] [args]${reset} - Execute pytest with test environment"
  echo "    • No args: run all tests"
  echo "    • With path: run specific test file or directory"
  echo "    • Examples: ${cyan}test run${reset}, ${cyan}test run tests/ichrisbirch/app/test_login.py -v${reset}"
  echo "  ${blue}test cov [path] [args]${reset} - Run pytest with coverage report"
  echo "    • Generates HTML coverage report in htmlcov/"
  echo
  echo "${green}Production Environment (Cloudflare Tunnel + Traefik):${reset}"
  echo "  ${blue}prod start${reset}     - Fetch SSM secrets and start production services"
  echo "  ${blue}prod stop${reset}      - Stop production services and remove containers"
  echo "  ${blue}prod restart${reset}   - Restart existing production containers without rebuilding"
  echo "  ${blue}prod rebuild${reset}   - Fetch SSM secrets, rebuild Docker images, and restart"
  echo "  ${blue}prod logs${reset}      - View production Docker container logs"
  echo "  ${blue}prod status${reset}    - Check production service status and URLs"
  echo "  ${blue}prod health${reset}    - Run comprehensive health checks for production services"
  echo "  ${blue}prod apihealth${reset} - HTTP health check against production API endpoint"
  echo
  echo "${green}Project Stats:${reset}"
  echo "  ${blue}stats${reset}               - Dashboard with code, tests, quality, and activity"
  echo "  ${blue}stats code${reset}          - Lines of code by language"
  echo "  ${blue}stats tests${reset}         - Test results, coverage, and slowest tests"
  echo "  ${blue}stats quality${reset}       - Issues caught by linters over 24h/7d/30d/all time"
  echo "  ${blue}stats activity [n]${reset}  - Commit activity graph (default: 7 days)"
  echo "  ${blue}stats events [n]${reset}    - Recent pre-commit hook events (default: 20)"
  echo "  ${blue}stats trends${reset}        - Velocity, code churn, test suite trends, and sparkline"
  echo
  echo "${green}Service URLs:${reset}"
  echo "  ${blue}Development${reset}: https://api.docker.localhost, https://app.docker.localhost, https://chat.docker.localhost"
  echo "  ${blue}Test${reset}:        https://api.test.localhost:8443, https://app.test.localhost:8443"
  echo "  ${blue}Production${reset}:  https://api.ichrisbirch.com, https://app.ichrisbirch.com (via Cloudflare Tunnel)"
  echo
  echo "${green}Technical Notes:${reset}"
  echo "  • Development/test use Traefik with local certificates for HTTPS"
  echo "  • Production uses Cloudflare Tunnel for HTTPS (Traefik receives HTTP internally)"
  echo "  • Development and test environments run simultaneously on different ports"
  echo "  • Production secrets fetched from AWS SSM Parameter Store"
  echo "  • Use ${blue}<env> health${reset} commands for comprehensive service validation"
}
# check if the first argument is empty and print usage if so
if [ -z "$1" ]; then
  usage
  exit 0
fi

case $1 in
help | -h | --help | -help)
  usage
  ;;
install)
  install
  ;;
open)
  open
  ;;
cd)
  project-cd
  ;;
logs)
  logs
  ;;
test)
  # Pass remaining arguments to test function (e.g., test run path/to/test.py -v)
  subcmd="$2"
  shift 2  # Remove 'ichrisbirch' and 'test' (note: $1 is 'test', $2 is subcommand)
  test-"$subcmd" "$@"
  ;;
testing)
  case "$2" in
  app-logs)
    # Handle app-logs with lines and --follow options
    testing-app-logs "$3" "$4"
    ;;
  app-logs-follow)
    # Simplified follow function
    testing-app-logs-follow
    ;;
  health)
    testing-health
    ;;
  *)
    # Default testing command pattern
    testing-"$2"
    ;;
  esac
  ;;
dev)
  case "$2" in
  health)
    dev-health
    ;;
  *)
    dev-"$2"
    ;;
  esac
  ;;
prod)
  case "$2" in
  health)
    prod-health
    ;;
  *)
    prod-"$2"
    ;;
  esac
  ;;
ssl-manager)
  ssl-manager "$2" "$3"
  ;;
stats)
  case "$2" in
  show | "")
    stats-show
    ;;
  code)
    stats-code
    ;;
  tests)
    stats-tests
    ;;
  quality)
    stats-quality
    ;;
  activity)
    stats-activity "$3"
    ;;
  events)
    stats-events "$3"
    ;;
  trends)
    stats-trends
    ;;
  *)
    echo "${red}Unknown stats command: $2${reset}"
    echo "Usage: ichrisbirch stats [code|tests|quality|activity|events|trends]"
    ;;
  esac
  ;;
*)
  echo "${red}!! '$1' is not a valid ichrisbirch command !!${reset}"
  echo ""
  usage
  ;;
esac
